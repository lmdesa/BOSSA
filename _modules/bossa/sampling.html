

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>bossa.sampling &mdash; BOSSA 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=8d563738"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            BOSSA
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../bossa.html">bossa package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">BOSSA</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">bossa.sampling</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for bossa.sampling</h1><div class="highlight"><pre>
<span></span><span class="c1"># TODO: Add module documentation</span>
<span class="c1"># TODO: Complete documentation</span>

<span class="sd">&quot;&quot;&quot;Sampling of arbitrary distributions, galaxy parameters and binary populations.&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">gc</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">pathlib</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">time</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">cached_property</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span>

<span class="kn">from</span> <span class="nn">astropy.cosmology</span> <span class="kn">import</span> <span class="n">WMAP9</span> <span class="k">as</span> <span class="n">cosmo</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">numpy._typing</span> <span class="kn">import</span> <span class="n">NDArray</span><span class="p">,</span> <span class="n">ArrayLike</span>
<span class="kn">from</span> <span class="nn">numpy.lib.recfunctions</span> <span class="kn">import</span> <span class="n">unstructured_to_structured</span>
<span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="kn">import</span> <span class="n">quad</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">fsolve</span><span class="p">,</span> <span class="n">fmin</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">UnivariateSpline</span>
<span class="kn">from</span> <span class="nn">concurrent.futures</span> <span class="kn">import</span> <span class="n">ProcessPoolExecutor</span>

<span class="c1">#import sys</span>
<span class="c1">#sys.path.append(&#39;..&#39;)</span>
<span class="kn">import</span> <span class="nn">bossa.imf</span> <span class="k">as</span> <span class="nn">imf</span>
<span class="kn">import</span> <span class="nn">bossa.sfh</span> <span class="k">as</span> <span class="nn">sfh</span>
<span class="kn">from</span> <span class="nn">bossa.imf</span> <span class="kn">import</span> <span class="n">Star</span><span class="p">,</span> <span class="n">IGIMF</span>
<span class="kn">from</span> <span class="nn">bossa.sfh</span> <span class="kn">import</span> <span class="n">MZR</span><span class="p">,</span> <span class="n">SFMR</span><span class="p">,</span> <span class="n">Corrections</span><span class="p">,</span> <span class="n">GSMF</span>
<span class="kn">from</span> <span class="nn">bossa.zams</span> <span class="kn">import</span> <span class="n">ZAMSSystemGenerator</span><span class="p">,</span> <span class="n">MultipleFraction</span>
<span class="kn">from</span> <span class="nn">bossa.utils</span> <span class="kn">import</span> <span class="n">interpolate</span><span class="p">,</span> <span class="n">ZOH_to_FeH</span><span class="p">,</span> <span class="n">create_logger</span><span class="p">,</span> <span class="n">format_time</span><span class="p">,</span> <span class="n">Length</span><span class="p">,</span> <span class="n">get_bin_centers</span><span class="p">,</span> \
    <span class="n">enumerate_bin_edges</span>
<span class="kn">from</span> <span class="nn">bossa.constants</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Z_SUN</span><span class="p">,</span> <span class="n">LOG_PATH</span><span class="p">,</span> <span class="n">BINARIES_CORRELATED_TABLE_PATH</span><span class="p">,</span> <span class="n">BINARIES_UNCORRELATED_TABLE_PATH</span><span class="p">,</span>
    <span class="n">IGIMF_ZAMS_DIR_PATH</span><span class="p">,</span> <span class="n">GALAXYGRID_DIR_PATH</span><span class="p">,</span> <span class="n">PHYSICAL_CORE_COUNT</span><span class="p">,</span> <span class="n">TOTAL_PHYSICAL_MEMORY</span>
<span class="p">)</span>


<span class="n">IMFLike</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">imf</span><span class="o">.</span><span class="n">Star</span><span class="p">,</span> <span class="n">imf</span><span class="o">.</span><span class="n">EmbeddedCluster</span><span class="p">,</span> <span class="n">imf</span><span class="o">.</span><span class="n">IGIMF</span><span class="p">]</span>
<span class="sd">&quot;&quot;&quot;Classes from :mod:`imf` with an ``imf(m)`` method.&quot;&quot;&quot;</span>


<div class="viewcode-block" id="powerlaw">
<a class="viewcode-back" href="../../bossa.html#bossa.sampling.powerlaw">[docs]</a>
<span class="k">def</span> <span class="nf">powerlaw</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return power-law with norm ``k`` and index ``a`` at ``x``.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">k</span> <span class="o">*</span> <span class="n">x</span> <span class="o">**</span> <span class="n">a</span></div>



<div class="viewcode-block" id="RandomSampling">
<a class="viewcode-back" href="../../bossa.html#bossa.sampling.RandomSampling">[docs]</a>
<span class="k">class</span> <span class="nc">RandomSampling</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Randomly sample an arbitrary IMF.</span>

<span class="sd">    This class is meant to speed up the sampling of an IMF defined as a</span>
<span class="sd">    numerical integral, as with :class:`imf.IGIMF`, by setting up an</span>
<span class="sd">    interpolator to compute probabilities.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    imf : :const:`IMFLike`</span>
<span class="sd">        Instance of an IMF class with an ``imf(m)`` method.</span>
<span class="sd">    discretization_points : int</span>
<span class="sd">        Number of masses on which to compute the IMF.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    imf : IMFLike</span>
<span class="sd">        Instance of an IMF class with an ``imf(m)`` method.</span>
<span class="sd">    m_trunc_min : float</span>
<span class="sd">        Lower truncation mass.</span>
<span class="sd">    m_trunc_max : float</span>
<span class="sd">        Upper truncation mass.</span>
<span class="sd">    sample : NDArray</span>
<span class="sd">        Last drawn sample.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">imf</span><span class="p">:</span> <span class="n">IMFLike</span><span class="p">,</span> <span class="n">discretization_points</span><span class="p">:</span><span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">imf</span> <span class="o">=</span> <span class="n">imf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m_trunc_min</span> <span class="o">=</span> <span class="n">imf</span><span class="o">.</span><span class="n">m_trunc_min</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m_trunc_max</span> <span class="o">=</span> <span class="n">imf</span><span class="o">.</span><span class="n">m_trunc_max</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_discretization_points</span> <span class="o">=</span> <span class="n">discretization_points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_discretization_masses</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">discrete_imf</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># TODO: set discretization_masses with np.logspace</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">discretization_masses</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;NDArray: Masses on which to compute the IMF.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_discretization_masses</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_discretization_points</span> <span class="o">//</span> <span class="mi">5</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_discretization_masses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span>
                <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m_trunc_min</span> <span class="o">+</span> <span class="mf">0.01</span><span class="p">,</span>
                            <span class="mf">0.1</span><span class="p">,</span>
                            <span class="mi">1</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">size</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m_trunc_min</span><span class="p">)))),</span>
                <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">size</span><span class="p">)[</span><span class="mi">1</span><span class="p">:],</span>
                <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">size</span><span class="p">)[</span><span class="mi">1</span><span class="p">:],</span>
                <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">size</span><span class="p">)[</span><span class="mi">1</span><span class="p">:],</span>
                <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">m_trunc_max</span><span class="p">,</span>
                            <span class="mi">1</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">size</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m_trunc_max</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)))[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_discretization_masses</span>

<div class="viewcode-block" id="RandomSampling.compute_imf">
<a class="viewcode-back" href="../../bossa.html#bossa.sampling.RandomSampling.compute_imf">[docs]</a>
    <span class="k">def</span> <span class="nf">compute_imf</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the IMF for interpolation.</span>

<span class="sd">        Computes the IMF at :attr:`discretization_points` mass values</span>
<span class="sd">        for the interpolator.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">discrete_imf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,),</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">discretization_masses</span><span class="p">:</span>
            <span class="n">imf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imf</span><span class="o">.</span><span class="n">imf</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">discrete_imf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">discrete_imf</span><span class="p">,</span> <span class="n">imf</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_get_probabilities</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sampling_masses</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ArrayLike</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return probabilities at ``sampling_masses``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sampling_masses : NDArray</span>
<span class="sd">            Array of masses for which to compute the probability.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sampling_probs : NDArray</span>
<span class="sd">            Array of probabilities corresponding to sampling_masses.</span>
<span class="sd">            Sums to 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ipY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">discrete_imf</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">discretization_masses</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">ipX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">discretization_masses</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">discretization_masses</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">sampling_probs</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">ipX</span><span class="p">,</span> <span class="n">ipY</span><span class="p">,</span> <span class="n">sampling_masses</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Near the truncation masses, where the IMF sharply drops to</span>
        <span class="c1"># zero, the interpolator may yield negative values, which we</span>
        <span class="c1"># account for here.</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">prob</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sampling_probs</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">prob</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">sampling_probs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">sampling_probs</span> <span class="o">/=</span> <span class="n">sampling_probs</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">sampling_probs</span>

<div class="viewcode-block" id="RandomSampling.get_sample">
<a class="viewcode-back" href="../../bossa.html#bossa.sampling.RandomSampling.get_sample">[docs]</a>
    <span class="k">def</span> <span class="nf">get_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m_min</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">m_max</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a sample of size ``n`` from ``m_min`` to ``m_max``.</span>

<span class="sd">        Returns a sample of size ``n`` between ``mmin`` and ``m_max``</span>
<span class="sd">        and stores it as :attr:`sample`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        m_min : float</span>
<span class="sd">            Sampling interval lower limit.</span>
<span class="sd">        m_max : float</span>
<span class="sd">            Sampling interval upper limit.</span>
<span class="sd">        n : int</span>
<span class="sd">            Sample size.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sample : NDArray</span>
<span class="sd">            ``(n,)``-shaped array containing the sample.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">sampling_masses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">m_min</span><span class="p">,</span> <span class="n">m_max</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">probabilities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_probabilities</span><span class="p">(</span><span class="n">sampling_masses</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">sampling_masses</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">probabilities</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample</span></div>
</div>



<div class="viewcode-block" id="GalaxyStellarMassSampling">
<a class="viewcode-back" href="../../bossa.html#bossa.sampling.GalaxyStellarMassSampling">[docs]</a>
<span class="k">class</span> <span class="nc">GalaxyStellarMassSampling</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sample galaxy stellar masses from a GSMF.</span>

<span class="sd">    This class performs a number- or mass-weighted sampling of galaxy</span>
<span class="sd">    stellar mass from the galaxy stellar mass function (GSMF) in</span>
<span class="sd">    :class:`sfh.GSMF`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    gsmf : :class:`sfh.GSMF`</span>
<span class="sd">        GSMF to sample.</span>
<span class="sd">    logm_min : float</span>
<span class="sd">        Log of sampling interval lower limit.</span>
<span class="sd">    logm_max : float</span>
<span class="sd">        Log of sampling interval upper limit.</span>
<span class="sd">    size : int</span>
<span class="sd">        Sample size.</span>
<span class="sd">    sampling : {&#39;number&#39;, &#39;mass&#39;, &#39;uniform&#39;}, default : &#39;number&#39;</span>
<span class="sd">        Whether to sample by galaxy number, stellar mass, or with</span>
<span class="sd">        uniform mass bins.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    gsmf : :class:`sfh.GSMF`</span>
<span class="sd">        GSMF to sample.</span>
<span class="sd">    logm_min : float</span>
<span class="sd">        Log of sampling interval lower limit.</span>
<span class="sd">    logm_max : float</span>
<span class="sd">        Log of sampling interval upper limit.</span>
<span class="sd">    sample_size : int</span>
<span class="sd">        Sample size.</span>
<span class="sd">    bin_limits : NDArray</span>
<span class="sd">        Limits of sampled mass bins.</span>
<span class="sd">    grid_ndensity_array : NDArray</span>
<span class="sd">        Number density within each mass bin.</span>
<span class="sd">    grid_density_array : NDArray</span>
<span class="sd">        Mass density within each mass bin.</span>
<span class="sd">    grid_logmasses : NDArray</span>
<span class="sd">        Sampled log galaxy stellar masses.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    GalaxyGrid :</span>
<span class="sd">        Implements this class to generate a grid of galaxy metallicities</span>
<span class="sd">        and star-formation rates over redshift.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The sampling method implemented in this class is equivalent to</span>
<span class="sd">    computing :attr:`sample_size` quantiles of the GSMF and assigning</span>
<span class="sd">    each one its average stellar mass. Option ``sampling=&#39;number&#39;``</span>
<span class="sd">    implements this for the ``GSMF(m)`` directly, while option</span>
<span class="sd">    ``sampling=&#39;number&#39;`` does it for ``m*GSMF(m)``. In the future this</span>
<span class="sd">    class might be streamlined with Numpy&#39;s quantile function.</span>

<span class="sd">    Option ``sampling=&#39;uniform&#39;`` sets :attr:`sample_size` uniform-width</span>
<span class="sd">    log mass bins.</span>

<span class="sd">    Sampling is performed for a fixed redshift (defined within</span>
<span class="sd">    :attr:`gsmf`). Besides the log stellar masses</span>
<span class="sd">    (:attr:`grid_logmasses`), this class also stores the total mass and</span>
<span class="sd">    number densities contained by each mass bin</span>
<span class="sd">    (:attr:`grid_density_array` and :attr:`grid_ndensity_array`</span>
<span class="sd">    respectively).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from bossa.sfh import GSMF</span>
<span class="sd">    &gt;&gt;&gt; gsmf = GSMF(redshift=0)</span>
<span class="sd">    &gt;&gt;&gt; galaxy_mass_sampler = GalaxyStellarMassSampling(gsmf,size=10)</span>
<span class="sd">    &gt;&gt;&gt; galaxy_mass_sampler.sample()</span>
<span class="sd">    &gt;&gt;&gt; galaxy_mass_sampler.grid_logmasses</span>
<span class="sd">    array([9.89241753, 8.99773241, 8.50334364, 8.14752827, 7.86839714,</span>
<span class="sd">           7.64216579, 7.45822559, 7.30385785, 7.17084443, 7.05398244])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gsmf</span><span class="p">:</span> <span class="n">sfh</span><span class="o">.</span><span class="n">GSMF</span><span class="p">,</span> <span class="n">logm_min</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">7.</span><span class="p">,</span> <span class="n">logm_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">12.</span><span class="p">,</span> <span class="n">size</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
                 <span class="n">sampling</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;number&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gsmf</span> <span class="o">=</span> <span class="n">gsmf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logm_min</span> <span class="o">=</span> <span class="n">logm_min</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logm_max</span> <span class="o">=</span> <span class="n">logm_max</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span> <span class="o">=</span> <span class="n">sampling</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_limits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_ndensity_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_density_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_logmasses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sampling</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;str: Whether to sample by galaxy number or stellar mass.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sampling</span>

    <span class="nd">@sampling</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">sampling</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sampling</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">sampling</span> <span class="o">==</span> <span class="s1">&#39;number&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sampling</span> <span class="o">=</span> <span class="s1">&#39;number&#39;</span>
        <span class="k">elif</span> <span class="n">sampling</span> <span class="o">==</span> <span class="s1">&#39;mass&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sampling</span> <span class="o">=</span> <span class="s1">&#39;mass&#39;</span>
        <span class="k">elif</span> <span class="n">sampling</span> <span class="o">==</span> <span class="s1">&#39;uniform&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sampling</span> <span class="o">=</span> <span class="s1">&#39;uniform&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Parameter &quot;sampling&quot; must be one of &#39;</span>
                             <span class="s1">&#39;&quot;number&quot;, &quot;mass&quot;.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_ratio</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logm_im1</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">logm_i</span> <span class="p">:</span><span class="nb">int</span><span class="p">,</span> <span class="n">logm_ip1</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the ratio of the GSMF integral in a bin.</span>

<span class="sd">        Integrate either ``GSMF(m)`` or ``m*GSMF(m)`` according to</span>
<span class="sd">        :attr:`sampling`. This function is used to check whether two</span>
<span class="sd">        consecutive mass bins hold the same mass/number density.</span>

<span class="sd">        Not called for uniform sampling.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        logm_im1 : float</span>
<span class="sd">            Log m_(i minus 1). Lower limit of the first bin.</span>
<span class="sd">        logm_i : float</span>
<span class="sd">            Log m_i. Upper limit of the first bin, lower of the second.</span>
<span class="sd">        logm_ip1 : float</span>
<span class="sd">            Log m_(i plus 1). Upper limit of the second bin.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Ratio of the integral in the first over the second bin.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span> <span class="o">==</span> <span class="s1">&#39;number&#39;</span><span class="p">:</span>
            <span class="n">int1</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">10</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsmf</span><span class="o">.</span><span class="n">log_gsmf</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">logm_ip1</span><span class="p">,</span> <span class="n">logm_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">int2</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">10</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsmf</span><span class="o">.</span><span class="n">log_gsmf</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">logm_i</span><span class="p">,</span> <span class="n">logm_im1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span> <span class="o">==</span> <span class="s1">&#39;mass&#39;</span><span class="p">:</span>
            <span class="n">int1</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">10</span> <span class="o">**</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsmf</span><span class="o">.</span><span class="n">log_gsmf</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">logm_ip1</span><span class="p">,</span> <span class="n">logm_i</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">int2</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">10</span> <span class="o">**</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsmf</span><span class="o">.</span><span class="n">log_gsmf</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">logm_i</span><span class="p">,</span> <span class="n">logm_im1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">int1</span> <span class="o">/</span> <span class="n">int2</span>

    <span class="k">def</span> <span class="nf">_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vec</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a vector to be minimized during sampling.</span>

<span class="sd">        Vector containing the (ratios - 1) between the integrals within</span>
<span class="sd">        successive mass bins. The integrals are computed by</span>
<span class="sd">        :meth:`_ratio`. The number of bins is fixed to</span>
<span class="sd">        :attr:`sample_size`, but their limits can be shifted around</span>
<span class="sd">        until they become the :attr:`sample_size`-quantiles of the GSMF,</span>
<span class="sd">        i.e., until `bin_density_ratios` becomes null. This is done by</span>
<span class="sd">        :meth:`sample`.</span>

<span class="sd">        Not called for uniform sampling.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vec : NDArray</span>
<span class="sd">            Boundaries of the mass bins, except for the extremes, i.e.,</span>
<span class="sd">            first lower boundary and last upper boundary.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bin_density_ratios : NDArray</span>
<span class="sd">            (Ratios - 1) of the number or mass integral between</span>
<span class="sd">            successive bins.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Add extremes to bin limits.</span>
        <span class="n">bin_limits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="bp">self</span><span class="o">.</span><span class="n">logm_max</span><span class="p">],</span> <span class="n">vec</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">logm_min</span><span class="p">]))</span>
        <span class="n">bin_density_ratios</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">logm_i</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bin_limits</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">logm_im1</span> <span class="o">=</span> <span class="n">bin_limits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># m_(i minus 1)</span>
            <span class="n">logm_ip1</span> <span class="o">=</span> <span class="n">bin_limits</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>  <span class="c1"># m_(i plus 1)</span>
            <span class="c1"># The first two conditions stops bins from &quot;crossing over&quot;.</span>
            <span class="k">if</span> <span class="n">logm_i</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">logm_max</span> <span class="ow">or</span> <span class="n">logm_ip1</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">logm_max</span><span class="p">:</span>
                <span class="n">bin_density_ratios</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1000</span>
            <span class="k">elif</span> <span class="n">logm_i</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">logm_min</span> <span class="ow">or</span> <span class="n">logm_ip1</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">logm_min</span><span class="p">:</span>
                <span class="n">bin_density_ratios</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1000</span>
            <span class="c1"># Only if there is no crossover is the actual ratio taken.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ratio</span><span class="p">(</span><span class="n">logm_im1</span><span class="p">,</span> <span class="n">logm_i</span><span class="p">,</span> <span class="n">logm_ip1</span><span class="p">)</span>
                <span class="n">bin_density_ratios</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">r</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">bin_density_ratios</span>

    <span class="k">def</span> <span class="nf">_set_grid_density</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Integrates within each bin for mass and number densities.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">m2</span><span class="p">,</span> <span class="n">m1</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_limits</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_limits</span><span class="p">[</span><span class="mi">1</span><span class="p">:])):</span>
            <span class="n">ndens</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">10</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsmf</span><span class="o">.</span><span class="n">log_gsmf</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">dens</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">10</span> <span class="o">**</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsmf</span><span class="o">.</span><span class="n">log_gsmf</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid_ndensity_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ndens</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid_density_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dens</span>

<div class="viewcode-block" id="GalaxyStellarMassSampling.sample">
<a class="viewcode-back" href="../../bossa.html#bossa.sampling.GalaxyStellarMassSampling.sample">[docs]</a>
    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sample galaxy stellar masses from the GSMF.</span>

<span class="sd">        Generates the galaxy stellar mass samples according to</span>
<span class="sd">        :attr:`sampling` and stores it in :attr:`grid_logmasses`. Number</span>
<span class="sd">        and mass densities of galaxies in each bin are also computed</span>
<span class="sd">        and stored in :attr:`grid_density_array` and</span>
<span class="sd">        :attr:`grid_ndensity_array`, respectively.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># No minimization problem if bins are uniform.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span> <span class="o">==</span> <span class="s1">&#39;uniform&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bin_limits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logm_max</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logm_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Use uniform bins as initial guesses.</span>
            <span class="c1"># A number-weighted sample is always weighted towards lower</span>
            <span class="c1"># masses relative to a mass-weighted one because less</span>
            <span class="c1"># massive galaxies are much more common.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span> <span class="o">==</span> <span class="s1">&#39;number&#39;</span><span class="p">:</span>
                <span class="n">initial_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logm_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling</span> <span class="o">==</span> <span class="s1">&#39;mass&#39;</span><span class="p">:</span>
                <span class="n">initial_guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">11</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># Minimize (ratio-1) bin integral vector.</span>
            <span class="c1"># See the _constraint docstring.</span>
            <span class="n">solution</span> <span class="o">=</span> <span class="n">fsolve</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_constraint</span><span class="p">,</span>
                              <span class="n">initial_guess</span><span class="p">,</span>
                              <span class="n">maxfev</span><span class="o">=</span><span class="p">(</span><span class="n">initial_guess</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bin_limits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="bp">self</span><span class="o">.</span><span class="n">logm_max</span><span class="p">],</span> <span class="n">solution</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">logm_min</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_grid_density</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">m2</span><span class="p">,</span> <span class="n">m1</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_limits</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_limits</span><span class="p">[</span><span class="mi">1</span><span class="p">:])):</span>
            <span class="n">number_density_in_bin</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">10</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsmf</span><span class="o">.</span><span class="n">log_gsmf</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">logmass_density_in_bin</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsmf</span><span class="o">.</span><span class="n">log_gsmf</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid_logmasses</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">logmass_density_in_bin</span> <span class="o">/</span> <span class="n">number_density_in_bin</span></div>
</div>



<div class="viewcode-block" id="GalaxyGrid">
<a class="viewcode-back" href="../../bossa.html#bossa.sampling.GalaxyGrid">[docs]</a>
<span class="k">class</span> <span class="nc">GalaxyGrid</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a grid of galaxy properties over redshift.</span>

<span class="sd">    This class uses the galaxy stellar mass function (GSMF), star</span>
<span class="sd">    formation-mass relation (SFMR) and mass-metallicity relation (MZR)</span>
<span class="sd">    models from the :mod:`sfh` module to sample the space of galaxy</span>
<span class="sd">    parameters (stellar mass, redshift, star formation rate and</span>
<span class="sd">    metallicity).</span>

<span class="sd">    A set of :attr:`n_redshift` redshifts is sampled first, and only</span>
<span class="sd">    then are the other three parameters sampled,</span>
<span class="sd">    :attr:`logm_per_redshift` sets per redshift. Unless</span>
<span class="sd">    :attr:`scatter_model`  is set to `normal`, the redshift plus any one</span>
<span class="sd">    parameter fully determines the others.</span>

<span class="sd">    Mass is given in solar masses, star formation rate in solar masses</span>
<span class="sd">    per year, and the metallicity is [Fe/H].</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n_redshift : int</span>
<span class="sd">        Number of redshift to sample.</span>
<span class="sd">    redshift_min : float, default : 0.</span>
<span class="sd">        Minimum redshift to sample.</span>
<span class="sd">    redshift_max : float, default : 10.</span>
<span class="sd">        Maximum redshift to sample.</span>
<span class="sd">    force_boundary_redshift : bool, default : True,</span>
<span class="sd">        Whether to manually add ``redshift_min`` and</span>
<span class="sd">        ``redshift_max`` to the sample.</span>
<span class="sd">    logm_per_redshift : int, default : 3</span>
<span class="sd">        Number of masses to sample per redshift.</span>
<span class="sd">    logm_min : float, default : 7</span>
<span class="sd">        Minimum log10(mass) to sample.</span>
<span class="sd">    logm_max : float, default : 12</span>
<span class="sd">        Maximum log10(mass) to sample.</span>
<span class="sd">    mzr_model : {&#39;KK04&#39;, &#39;T04&#39;, &#39;M09&#39;, &#39;PP04&#39;}, default: &#39;KK04&#39;</span>
<span class="sd">        Option of MZR model.</span>
<span class="sd">    sfmr_flattening : {&#39;none&#39;, &#39;moderate&#39;, &#39;sharp&#39;}, default: &#39;none&#39;</span>
<span class="sd">        SFMR model flattening option.</span>
<span class="sd">    gsmf_slope_fixed : bool, default: True</span>
<span class="sd">        Whether to use the fixed (True) or the varying (False)</span>
<span class="sd">        GSMF low-mass slope model.</span>
<span class="sd">    sampling_mode : {&#39;mass&#39;, &#39;number&#39;, &#39;uniform&#39;}, default : &#39;mass&#39;</span>
<span class="sd">        Method for sampling masse from the GSMF.</span>
<span class="sd">    scatter_model : str, default : &#39;none&#39;</span>
<span class="sd">        Scatter model to use in the SFMR and MZR.</span>
<span class="sd">    apply_igimf_corrections : bool, default : True,</span>
<span class="sd">        Whether to correct the SFR for :class:`imf.IGIMF`.</span>
<span class="sd">    random_state : int</span>
<span class="sd">        Random number generator seed.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    n_redshift : int</span>
<span class="sd">        Number of redshift values in the grid.</span>
<span class="sd">    redshift_min : float</span>
<span class="sd">        Minimum redshift to sample.</span>
<span class="sd">    redshift_max : float</span>
<span class="sd">        Maximum redshift to sample.</span>
<span class="sd">    force_boundary_redshift : bool</span>
<span class="sd">        Whether to forcefully add redshifts :attr:`redshift_min` and</span>
<span class="sd">        :attr:`redshift_min` to the sample, thus making its size</span>
<span class="sd">        ``(n_redshift+2)*``:attr:`logm_per_redshift`.</span>
<span class="sd">    logm_per_redshift : int</span>
<span class="sd">        Number of galactic stellar masses to sample per redshift.</span>
<span class="sd">    logm_min : float</span>
<span class="sd">        Minimum log10(mass) to sample.</span>
<span class="sd">    logm_max : float</span>
<span class="sd">        Maximum log10(mass) to sample.</span>
<span class="sd">    sample_redshift_array : NDArray</span>
<span class="sd">        Redshift sample defining the grid.</span>
<span class="sd">    sample_redshift_bins : NDArray</span>
<span class="sd">        Limits of the bins represented by :attr:`sample_redshift_array`.</span>
<span class="sd">    sample_logm_array : NDArray</span>
<span class="sd">        Galaxy stellar mass samples for each redshift in</span>
<span class="sd">        :attr:`sample_redshift_array`.</span>
<span class="sd">    sample_logm_bins : NDArray</span>
<span class="sd">        Limits of the bins represented by :attr:`sample_logm_array`,</span>
<span class="sd">        per redshift.</span>
<span class="sd">    gsmf_slope_fixed : bool</span>
<span class="sd">        Whether the GSMF low-mass slope should be fixed or not.</span>
<span class="sd">    random_state : int</span>
<span class="sd">        Random number generator seed.</span>
<span class="sd">    apply_igimf_corrections : bool</span>
<span class="sd">        Whether to correct the SFR for :class:`imf.IGIMF`.</span>
<span class="sd">    zoh_bin_array : NDArray</span>
<span class="sd">        Edges of Z_OH bins represented by :attr:`zoh_array`.</span>
<span class="sd">    zoh_array : NDArray</span>
<span class="sd">        Z_OH values sampled at each redshift.</span>
<span class="sd">    ndensity_array : NDArray</span>
<span class="sd">        Number density of galaxies represented by each grid point.</span>
<span class="sd">    density_array : NDArray</span>
<span class="sd">        Stellar mass density of galaxies represented by each grid point.</span>
<span class="sd">    mass_list : list</span>
<span class="sd">        List of :attr:`n_redshift` arrays, containing the galaxy stellar</span>
<span class="sd">        masses sampled at each redshift.</span>
<span class="sd">    log_gsmf_list : list</span>
<span class="sd">        List of :attr:`n_redshift` arrays, containing the log10(gsmf)</span>
<span class="sd">        values (galaxy number density) sampled at each redshift.</span>
<span class="sd">    zoh_list : list</span>
<span class="sd">        List of :attr:`n_redshift` arrays, containing the Z_OH values</span>
<span class="sd">        sampled at each redshift.</span>
<span class="sd">    feh_list : list</span>
<span class="sd">        List of :attr:`n_redshift`, containing the [Fe/H] values</span>
<span class="sd">        sampled at each redshift.</span>
<span class="sd">    sfr_list : list</span>
<span class="sd">        List of :attr:`n_redshift` arrays, containing the SFR values</span>
<span class="sd">        sampled at each redshift.</span>
<span class="sd">    grid_array : numpy_array</span>
<span class="sd">        Shape ``(n_redshift, logm_per_redshift, 6)`` array containing</span>
<span class="sd">        the full grid of galaxy properties.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This class first samples the redshift, and then for each redshift</span>
<span class="sd">    a fixed number of &quot;galaxies&quot;, i.e., (mass, metallicity, SFR) sets.</span>
<span class="sd">    The final grid of galaxies is stored as :attr:`grid_array`, and can</span>
<span class="sd">    also be written to disk as a .pkl file with Pandas by calling</span>
<span class="sd">    :meth:`save_grid`. The ``_array`` attributes are used to build</span>
<span class="sd">    :attr:`grid_array`. The ``_list`` attributes are not used</span>
<span class="sd">    internally, but were instead necessary for older versions of data</span>
<span class="sd">    analysis/processing and test notebooks.</span>

<span class="sd">    :attr:`sample_redshift_array` is initialized as a sample of</span>
<span class="sd">    evenly-space redshifts between the set minimum and maximum.</span>
<span class="sd">    :meth:`sample_redshift` must be run to get a sample from the GSMF.</span>

<span class="sd">    It is recommended not to rely on the ``_list`` attributes, as they</span>
<span class="sd">    should be removed in the future.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Chruslinska, M., Jerabkova, T., Nelemans, G., Yan, Z.</span>
<span class="sd">       (2020). The effect of the environment-dependent IMF on the</span>
<span class="sd">       formation and metallicities of stars over cosmic history.</span>
<span class="sd">       A&amp;A, 636, A10. doi:10.1051/0004-6361/202037688</span>
<span class="sd">    .. [2] Jerabkova, T., Zonoozi, A. H., Kroupa, P., Beccari, G.,</span>
<span class="sd">       Yan, Z., Vazdekis, A., Zhang, Z.-Y. (2018). Impact of</span>
<span class="sd">       metallicity and star formation rate on the time-dependent,</span>
<span class="sd">       galaxy-wide stellar initial mass function. A&amp;A, 620, A39.</span>
<span class="sd">       doi:10.1051/0004-6361/20183</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n_redshift</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">redshift_min</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">,</span> <span class="n">redshift_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">10.</span><span class="p">,</span>
                 <span class="n">force_boundary_redshift</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">logm_per_redshift</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
                 <span class="n">logm_min</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">6.</span><span class="p">,</span> <span class="n">logm_max</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">12.</span><span class="p">,</span> <span class="n">mzr_model</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;KK04&#39;</span><span class="p">,</span>
                 <span class="n">sfmr_flattening</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="n">gsmf_slope_fixed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                 <span class="n">sampling_mode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;sfr&#39;</span><span class="p">,</span> <span class="n">scatter_model</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;none&#39;</span><span class="p">,</span>
                 <span class="n">apply_igimf_corrections</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">random_state</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Redshift settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_redshift</span> <span class="o">=</span> <span class="n">n_redshift</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">redshift_min</span> <span class="o">=</span> <span class="n">redshift_min</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">redshift_max</span> <span class="o">=</span> <span class="n">redshift_max</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">force_boundary_redshift</span> <span class="o">=</span> <span class="n">force_boundary_redshift</span>

        <span class="c1"># Logm settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logm_per_redshift</span> <span class="o">=</span> <span class="n">logm_per_redshift</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logm_min</span> <span class="o">=</span> <span class="n">logm_min</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logm_max</span> <span class="o">=</span> <span class="n">logm_max</span>

        <span class="c1"># Galaxy sampling storage</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_redshift_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_sample_redshift_array</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_redshift_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_redshift_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_logm_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_redshift_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">logm_per_redshift</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_logm_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_redshift_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">logm_per_redshift</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Physical models</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mzr_model</span> <span class="o">=</span> <span class="n">mzr_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sfmr_flattening</span> <span class="o">=</span> <span class="n">sfmr_flattening</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gsmf_slope_fixed</span> <span class="o">=</span> <span class="n">gsmf_slope_fixed</span>

        <span class="c1"># Sampling settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling_mode</span> <span class="o">=</span> <span class="n">sampling_mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scatter_model</span> <span class="o">=</span> <span class="n">scatter_model</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="o">=</span> <span class="n">random_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">apply_igimf_corrections</span> <span class="o">=</span> <span class="n">apply_igimf_corrections</span>

        <span class="c1"># Logm sampling storage</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zoh_bin_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logm_per_redshift</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zoh_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logm_per_redshift</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ndensity_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logm_per_redshift</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">density_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logm_per_redshift</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mass_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log_gsmf_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zoh_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">feh_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sfr_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="c1"># Grid storage</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_save_path</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># TODO: document sampling grid attributes</span>
        <span class="c1"># Sampling grid attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_side</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_redshift</span><span class="o">*</span><span class="mi">5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_samplesize_per_bin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">logm_per_redshift</span><span class="o">*</span><span class="mi">10</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_redshift_bins</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_logm_bins</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_zoh_axis</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_logsfr_axis</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_logsfrd_overlay</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">random_state</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">random_state</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_sample_redshift_array</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return initial uniform redshift array.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">force_boundary_redshift</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">redshift_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">redshift_max</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_redshift</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">redshift_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">redshift_max</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_redshift</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mzr_model</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mass-(gas) metallicity relation model choice.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mzr_model</span>

    <span class="nd">@mzr_model</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">mzr_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">models</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;KK04&#39;</span><span class="p">,</span> <span class="s1">&#39;T04&#39;</span><span class="p">,</span> <span class="s1">&#39;M09&#39;</span><span class="p">,</span> <span class="s1">&#39;PP04&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">model</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">models</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;mzr_model must be one of </span><span class="si">{</span><span class="n">models</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mzr_model</span> <span class="o">=</span> <span class="n">model</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sfmr_flattening</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Star formation-mass relation model choice.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sfmr_flattening</span>

    <span class="nd">@sfmr_flattening</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">sfmr_flattening</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">flattening</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">models</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="s1">&#39;moderate&#39;</span><span class="p">,</span> <span class="s1">&#39;sharp&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">flattening</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">models</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;sfmr_flattening must be one of </span><span class="si">{</span><span class="n">models</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sfmr_flattening</span> <span class="o">=</span> <span class="n">flattening</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sampling_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sampling mode choice.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sampling_mode</span>

    <span class="nd">@sampling_mode</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">sampling_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">modes</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;sfr&#39;</span><span class="p">,</span> <span class="s1">&#39;mass&#39;</span><span class="p">,</span> <span class="s1">&#39;number&#39;</span><span class="p">,</span> <span class="s1">&#39;uniform&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">modes</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;sampling mode must be one of </span><span class="si">{</span><span class="n">modes</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sampling_mode</span> <span class="o">=</span> <span class="n">mode</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">scatter_model</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Scattering model choice for the SFMR and the MZR.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scatter_model</span>

    <span class="nd">@scatter_model</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">scatter_model</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">models</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;none&#39;</span><span class="p">,</span> <span class="s1">&#39;normal&#39;</span><span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">model</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">models</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;sampling mode must be one of </span><span class="si">{</span><span class="n">models</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_scatter_model</span> <span class="o">=</span> <span class="n">model</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">save_path</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pathlib</span><span class="o">.</span><span class="n">Path</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;pathlib.Path: Path which to save the grid to.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;galgrid_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">mzr_model</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">sfmr_flattening</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">gsmf_slope_fixed</span><span class="si">}</span><span class="s1">_&#39;</span>
                     <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_mode</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_redshift_array</span><span class="p">)</span><span class="si">}</span><span class="s1">z_&#39;</span>
                     <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">logm_per_redshift</span><span class="si">}</span><span class="s1">Z.pkl&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_save_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">GALAXYGRID_DIR_PATH</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_path</span>

    <span class="k">def</span> <span class="nf">_discrete_redshift_probs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_z</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">max_z</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                                 <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">NDArray</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return probabilities for a uniform redshift pool.</span>

<span class="sd">        Generates and returns a ``pool`` of evenly-space ``size```</span>
<span class="sd">        redshifts between ``min_z`` and ``max_z``. Computes and returns</span>
<span class="sd">        their probabilities (``probs``) from the number of galaxies at</span>
<span class="sd">        that redshift, found by integrating either ``m*GSMF(m)`` or</span>
<span class="sd">        ``SFR(m)*GSMF(m)`` over the entire mass span at each redshift.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">min_z</span><span class="p">,</span> <span class="n">max_z</span><span class="p">,</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">pool</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="n">probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">z_llim</span><span class="p">,</span> <span class="n">z_ulim</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:])):</span>
            <span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">z_llim</span> <span class="o">+</span> <span class="n">z_ulim</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">gsmf</span> <span class="o">=</span> <span class="n">GSMF</span><span class="p">(</span><span class="n">redshift</span><span class="o">=</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                        <span class="n">fixed_slope</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gsmf_slope_fixed</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_mode</span> <span class="o">==</span> <span class="s1">&#39;sfr&#39;</span><span class="p">:</span>
                <span class="n">sfmr</span> <span class="o">=</span> <span class="n">SFMR</span><span class="p">(</span><span class="n">redshift</span><span class="o">=</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                            <span class="n">flattening</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sfmr_flattening</span><span class="p">,</span>
                            <span class="n">scatter_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scatter_model</span><span class="p">)</span>
                <span class="k">def</span> <span class="nf">sfrd_dlogm</span><span class="p">(</span><span class="n">logm</span><span class="p">):</span>
                    <span class="c1"># Return the star formation rate density per</span>
                    <span class="c1"># logarithmic galaxy stellar mass bin.</span>
                    <span class="k">return</span> <span class="mf">10.</span><span class="o">**</span><span class="n">gsmf</span><span class="o">.</span><span class="n">log_gsmf</span><span class="p">(</span><span class="n">logm</span><span class="p">)</span> <span class="o">*</span> <span class="mf">10.</span><span class="o">**</span><span class="n">sfmr</span><span class="o">.</span><span class="n">logsfr</span><span class="p">(</span><span class="n">logm</span><span class="p">)</span>
                <span class="c1"># Get the total star formation rate density at redshift.</span>
                <span class="n">sfrd</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="n">sfrd_dlogm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logm_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logm_max</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">probs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sfrd</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_mode</span> <span class="o">==</span> <span class="s1">&#39;mass&#39;</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">density_dlogm</span><span class="p">(</span><span class="n">logm</span><span class="p">):</span>
                    <span class="c1"># Return the (stellar) mass density of galaxies</span>
                    <span class="c1"># of (stellar) mass logm per logarithmic galaxy</span>
                    <span class="c1"># stellar mass bin.</span>
                    <span class="k">return</span> <span class="n">logm</span> <span class="o">*</span> <span class="mf">10.</span><span class="o">**</span><span class="n">gsmf</span><span class="o">.</span><span class="n">log_gsmf</span><span class="p">(</span><span class="n">logm</span><span class="p">)</span>
                <span class="c1"># Get the total galaxy (stellar) mass density at</span>
                <span class="c1"># redshift.</span>
                <span class="c1"># We assume the density is uniform within the redshift bin.</span>
                <span class="n">c_vol</span> <span class="o">=</span> <span class="n">cosmo</span><span class="o">.</span><span class="n">comoving_volume</span><span class="p">(</span><span class="n">z_ulim</span><span class="p">)</span><span class="o">.</span><span class="n">value</span> <span class="o">-</span> <span class="n">cosmo</span><span class="o">.</span><span class="n">comoving_volume</span><span class="p">(</span><span class="n">z_llim</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
                <span class="n">density</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="n">density_dlogm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logm_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logm_max</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">probs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">density</span> <span class="o">*</span> <span class="n">c_vol</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_mode</span> <span class="o">==</span> <span class="s1">&#39;number&#39;</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">ndensity_dlogm</span><span class="p">(</span><span class="n">logm</span><span class="p">):</span>
                    <span class="c1"># Return the number density of galaxies of (stellar)</span>
                    <span class="c1"># mass logm per logarithmic galaxy stellar mass bin.</span>
                    <span class="k">return</span> <span class="mf">10.</span><span class="o">**</span><span class="n">gsmf</span><span class="o">.</span><span class="n">log_gsmf</span><span class="p">(</span><span class="n">logm</span><span class="p">)</span>
                <span class="c1"># Get the total number density at redshift.</span>
                <span class="c1"># We assume the density is uniform within the redshift bin.</span>
                <span class="n">c_vol</span> <span class="o">=</span> <span class="n">cosmo</span><span class="o">.</span><span class="n">comoving_volume</span><span class="p">(</span><span class="n">z_ulim</span><span class="p">)</span><span class="o">.</span><span class="n">value</span> <span class="o">-</span> <span class="n">cosmo</span><span class="o">.</span><span class="n">comoving_volume</span><span class="p">(</span><span class="n">z_llim</span><span class="p">)</span><span class="o">.</span><span class="n">value</span>
                <span class="n">density</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="n">ndensity_dlogm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logm_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logm_max</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">probs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">density</span> <span class="o">*</span> <span class="n">c_vol</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_mode</span> <span class="o">==</span> <span class="s1">&#39;uniform&#39;</span><span class="p">:</span>
                <span class="n">probs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>

        <span class="n">probs</span> <span class="o">/=</span> <span class="n">probs</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">pool</span><span class="p">,</span> <span class="n">probs</span>

    <span class="k">def</span> <span class="nf">_gsmf_sample_masses</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">redshift</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">GalaxyStellarMassSampling</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sample masses from the GSMF at ``redshift``.</span>

<span class="sd">        Returns a :class:`sfh.GSMF` object which holds the sampled</span>
<span class="sd">        masses and respective densities as attributes.</span>

<span class="sd">        Warnings</span>
<span class="sd">        --------</span>
<span class="sd">        This method is deprecated and will be removed in the next</span>
<span class="sd">        version.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">gsmf</span> <span class="o">=</span> <span class="n">GSMF</span><span class="p">(</span><span class="n">redshift</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gsmf_slope_fixed</span><span class="p">)</span>
        <span class="n">sample</span> <span class="o">=</span> <span class="n">GalaxyStellarMassSampling</span><span class="p">(</span><span class="n">gsmf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logm_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logm_max</span><span class="p">,</span>
                                           <span class="bp">self</span><span class="o">.</span><span class="n">logm_per_redshift</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_mode</span><span class="p">)</span>
        <span class="n">sample</span><span class="o">.</span><span class="n">sample</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">sample</span>

    <span class="k">def</span> <span class="nf">_discrete_mass_probs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_logm</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">max_logm</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">redshift</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                                 <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">NDArray</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return probabilities for a uniform mass pool at a redshift.</span>

<span class="sd">        Generates and returns a ``pool`` of evenly-space ``size``</span>
<span class="sd">        galaxy stellar masses between ``min_logm`` and ``max_logm``.</span>
<span class="sd">        Computes and returns their probabilities (``probs``) weighted</span>
<span class="sd">        by either density (mass or number), or SFRD.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">bin_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">min_logm</span><span class="p">,</span> <span class="n">max_logm</span><span class="p">,</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">pool</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="n">probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="n">gsmf</span> <span class="o">=</span> <span class="n">GSMF</span><span class="p">(</span><span class="n">redshift</span><span class="o">=</span><span class="n">redshift</span><span class="p">,</span>
                    <span class="n">fixed_slope</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gsmf_slope_fixed</span><span class="p">)</span>
        <span class="n">sfmr</span> <span class="o">=</span> <span class="n">SFMR</span><span class="p">(</span><span class="n">redshift</span><span class="o">=</span><span class="n">redshift</span><span class="p">,</span>
                    <span class="n">flattening</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sfmr_flattening</span><span class="p">,</span>
                    <span class="n">scatter_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scatter_model</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">logm0</span><span class="p">,</span> <span class="n">logm1</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">bin_edges</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">bin_edges</span><span class="p">[</span><span class="mi">1</span><span class="p">:])):</span>
            <span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">logm0</span> <span class="o">+</span> <span class="n">logm1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_mode</span> <span class="o">==</span> <span class="s1">&#39;sfr&#39;</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">sfrd_dlogm</span><span class="p">(</span><span class="n">logm</span><span class="p">):</span>
                    <span class="c1"># Return the star formation rate density per</span>
                    <span class="c1"># logarithmic galaxy stellar mass bin.</span>
                    <span class="k">return</span> <span class="mf">10.</span> <span class="o">**</span> <span class="n">gsmf</span><span class="o">.</span><span class="n">log_gsmf</span><span class="p">(</span><span class="n">logm</span><span class="p">)</span> <span class="o">*</span> <span class="mf">10.</span> <span class="o">**</span> <span class="n">sfmr</span><span class="o">.</span><span class="n">logsfr</span><span class="p">(</span><span class="n">logm</span><span class="p">)</span>
                <span class="n">probs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sfrd_dlogm</span><span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_mode</span> <span class="o">==</span> <span class="s1">&#39;mass&#39;</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">density_dlogm</span><span class="p">(</span><span class="n">logm</span><span class="p">):</span>
                    <span class="c1"># Return the (stellar) mass density of galaxies</span>
                    <span class="c1"># of (stellar) mass logm per logarithmic galaxy</span>
                    <span class="c1"># stellar mass bin.</span>
                    <span class="k">return</span> <span class="n">logm</span> <span class="o">*</span> <span class="mf">10.</span> <span class="o">**</span> <span class="n">gsmf</span><span class="o">.</span><span class="n">log_gsmf</span><span class="p">(</span><span class="n">logm</span><span class="p">)</span>

                <span class="c1"># Get the total galaxy (stellar) mass at redshift.</span>
                <span class="n">c_vol</span> <span class="o">=</span> <span class="n">cosmo</span><span class="o">.</span><span class="n">differential_comoving_volume</span><span class="p">(</span><span class="n">redshift</span><span class="p">)</span>
                <span class="n">density</span> <span class="o">=</span> <span class="n">density_dlogm</span><span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">probs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">density</span> <span class="o">*</span> <span class="n">c_vol</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_mode</span> <span class="o">==</span> <span class="s1">&#39;number&#39;</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">ndensity_dlogm</span><span class="p">(</span><span class="n">logm</span><span class="p">):</span>
                    <span class="c1"># Return the number density of galaxies of (stellar)</span>
                    <span class="c1"># mass logm per logarithmic galaxy stellar mass bin.</span>
                    <span class="k">return</span> <span class="mf">10.</span> <span class="o">**</span> <span class="n">gsmf</span><span class="o">.</span><span class="n">log_gsmf</span><span class="p">(</span><span class="n">logm</span><span class="p">)</span>

                <span class="c1"># Get the total number at redshift.</span>
                <span class="n">c_vol</span> <span class="o">=</span> <span class="n">cosmo</span><span class="o">.</span><span class="n">differential_comoving_volume</span><span class="p">(</span><span class="n">redshift</span><span class="p">)</span>
                <span class="n">density</span> <span class="o">=</span> <span class="n">ndensity_dlogm</span><span class="p">(</span><span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">probs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">density</span> <span class="o">*</span> <span class="n">c_vol</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_mode</span> <span class="o">==</span> <span class="s1">&#39;uniform&#39;</span><span class="p">:</span>
                <span class="n">probs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>

        <span class="n">probs</span> <span class="o">/=</span> <span class="n">probs</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">pool</span><span class="p">,</span> <span class="n">probs</span>

    <span class="c1"># TODO: implement density-weighted sampling within this method</span>
    <span class="k">def</span> <span class="nf">_sample_masses</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sample galaxy stellar mass at ``redshift``.</span>

<span class="sd">        Depending on ``sampling_mode``, sample galaxy stellar mass with</span>
<span class="sd">        probability weighted by galaxy number density, galaxy stellar</span>
<span class="sd">        mass density or star formation rate density (SFRD).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">redshift_i</span><span class="p">,</span> <span class="n">redshift</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_redshift_array</span><span class="p">):</span>
            <span class="n">logm_pool</span><span class="p">,</span> <span class="n">logm_probs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_discrete_mass_probs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logm_min</span><span class="p">,</span>
                                                              <span class="bp">self</span><span class="o">.</span><span class="n">logm_max</span><span class="p">,</span>
                                                              <span class="n">redshift</span><span class="o">=</span><span class="n">redshift</span><span class="p">,</span>
                                                              <span class="n">size</span><span class="o">=</span><span class="mi">100</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">logm_per_redshift</span><span class="p">)</span>

            <span class="c1"># With probabilities calculated, we can generate a</span>
            <span class="c1"># representative sample from which we find logm_per_redshift)</span>
            <span class="c1"># quantiles. Repetition is not an issue because only the</span>
            <span class="c1"># quantiles are of interest (so we can ask for a sample larger</span>
            <span class="c1"># than logm_pool).</span>
            <span class="n">logm_choices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">logm_pool</span><span class="p">,</span>
                                            <span class="n">p</span><span class="o">=</span><span class="n">logm_probs</span><span class="p">,</span>
                                            <span class="n">size</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mf">1e4</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">logm_per_redshift</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sample_logm_bins</span><span class="p">[</span><span class="n">redshift_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span>
                <span class="n">logm_choices</span><span class="p">,</span>
                <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logm_per_redshift</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="c1"># Correct for the granularity of the sampling.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sample_logm_bins</span><span class="p">[</span><span class="n">redshift_i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">logm_min</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sample_logm_bins</span><span class="p">[</span><span class="n">redshift_i</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">logm_max</span>

            <span class="c1"># Finding uniform quantiles defines which regions of the</span>
            <span class="c1"># redshift range should be equally represented in order</span>
            <span class="c1"># to reproduce the GSMF as well as possible. The quantiles</span>
            <span class="c1"># themselves are represented in the sample by the averaged</span>
            <span class="c1"># redshift of their respective galaxies. Weighting depends on</span>
            <span class="c1"># :attr:`sampling_mode`.</span>
            <span class="n">logm_i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">quantile0</span><span class="p">,</span> <span class="n">quantile1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_logm_bins</span><span class="p">[</span><span class="n">redshift_i</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                            <span class="bp">self</span><span class="o">.</span><span class="n">sample_logm_bins</span><span class="p">[</span><span class="n">redshift_i</span><span class="p">,</span> <span class="mi">1</span><span class="p">:]):</span>
                <span class="n">logm_pool</span><span class="p">,</span> <span class="n">logm_probs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_discrete_mass_probs</span><span class="p">(</span><span class="n">quantile0</span><span class="p">,</span>
                                                                  <span class="n">quantile1</span><span class="p">,</span>
                                                                  <span class="n">redshift</span><span class="o">=</span><span class="n">redshift</span><span class="p">,</span>
                                                                  <span class="n">size</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
                <span class="n">average_logm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">logm_pool</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">logm_probs</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sample_logm_array</span><span class="p">[</span><span class="n">redshift_i</span><span class="p">,</span> <span class="n">logm_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">average_logm</span>
                <span class="n">logm_i</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_sample_galaxies</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">redshift</span><span class="p">:</span> <span class="nb">float</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">NDArray</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">NDArray</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">NDArray</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">NDArray</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
               <span class="n">NDArray</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">NDArray</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">NDArray</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">NDArray</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">NDArray</span><span class="p">[</span><span class="nb">bool</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a sample of galaxies properties at ``redshift``.</span>

<span class="sd">        Samples a number :attr:`logm_per_redshift` of galaxies at</span>
<span class="sd">        ``redshift`` from the GSMF, SFMR and MZR. Returns a tuple of</span>
<span class="sd">        ``(len(logm_per_redshift),)``-shaped arrays.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        redshift : float</span>
<span class="sd">            Redshift. Defines the GSMF, MZR and SFMR.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndensity_array : NDArray</span>
<span class="sd">            ``(len(logm_per_redshift),)``-shaped array containing the</span>
<span class="sd">            galaxy number density within the mass bin represented by</span>
<span class="sd">            each galaxy.</span>
<span class="sd">        density_array : NDArray</span>
<span class="sd">            ``(len(logm_per_redshift),)``-shaped array containing the</span>
<span class="sd">            galaxy stellar mass density within the mass bin  represented</span>
<span class="sd">            by each galaxy.</span>
<span class="sd">        logm_array : NDArray</span>
<span class="sd">            ``(len(logm_per_redshift),)``-shaped array containing the</span>
<span class="sd">            log stellar mass of each galaxy.</span>
<span class="sd">        log_gsmf_array : NDArray</span>
<span class="sd">            ``(len(logm_per_redshift),)``-shaped array containing the</span>
<span class="sd">            log GSMF evaluated along ``logm_array``.</span>
<span class="sd">        zoh_array : NDArray</span>
<span class="sd">            ``(len(logm_per_redshift),)``-shaped array containing the</span>
<span class="sd">            Z_OH of each galaxy.</span>
<span class="sd">        zoh_bins : NDArray</span>
<span class="sd">            ``(len(logm_per_redshift)+1,)``-shaped array containing the</span>
<span class="sd">            limits of the Z_OH bins represented by each galaxy.</span>
<span class="sd">        feh_array : NDArray</span>
<span class="sd">            ``(len(logm_per_redshift),)``-shaped array containing the</span>
<span class="sd">            [Fe/H] of each galaxy.</span>
<span class="sd">        feh_mask : NDArray</span>
<span class="sd">            ``(len(logm_per_redshift),)``-shaped array acting as a</span>
<span class="sd">            boolean mask for values of ``feh_array`` within the bounds</span>
<span class="sd">            of :class:`sfh.Corrections`.</span>
<span class="sd">        log_sfr_array ; NDArray</span>
<span class="sd">            ``(len(logm_per_redshift),)``-shaped array containing the</span>
<span class="sd">            log SFR of each galaxy.</span>
<span class="sd">        sfr_mask : NDArray</span>
<span class="sd">            ``(len(logm_per_redshift),)``-shaped array acting as a</span>
<span class="sd">            boolean mask for values of ``sfr_array`` within the bounds</span>
<span class="sd">            of :class:`sfh.Corrections`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">i_redshift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">redshift</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_redshift_array</span><span class="p">))</span>
        <span class="n">logm_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_logm_array</span><span class="p">[</span><span class="n">i_redshift</span><span class="p">]</span>
        <span class="n">logm_bins</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_logm_bins</span><span class="p">[</span><span class="n">i_redshift</span><span class="p">]</span>

        <span class="n">gsmf</span> <span class="o">=</span> <span class="n">GSMF</span><span class="p">(</span><span class="n">redshift</span><span class="p">)</span>
        <span class="n">sfmr</span> <span class="o">=</span> <span class="n">SFMR</span><span class="p">(</span><span class="n">redshift</span><span class="p">,</span> <span class="n">flattening</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sfmr_flattening</span><span class="p">,</span> <span class="n">scatter_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scatter_model</span><span class="p">)</span>
        <span class="n">mzr</span> <span class="o">=</span> <span class="n">MZR</span><span class="p">(</span><span class="n">redshift</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mzr_model</span><span class="p">,</span> <span class="n">scatter_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scatter_model</span><span class="p">)</span>
        <span class="n">mzr</span><span class="o">.</span><span class="n">set_params</span><span class="p">()</span>

        <span class="n">density_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logm_per_redshift</span><span class="p">)</span>
        <span class="n">ndensity_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logm_per_redshift</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logm_per_redshift</span><span class="p">):</span>
            <span class="n">logm0</span><span class="p">,</span> <span class="n">logm1</span> <span class="o">=</span> <span class="n">logm_bins</span><span class="p">[[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">density_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">logm</span><span class="p">:</span> <span class="n">logm</span> <span class="o">*</span> <span class="mf">10.</span><span class="o">**</span><span class="n">gsmf</span><span class="o">.</span><span class="n">log_gsmf</span><span class="p">(</span><span class="n">logm</span><span class="p">),</span>
                                    <span class="n">logm0</span><span class="p">,</span>
                                    <span class="n">logm1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ndensity_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">logm</span><span class="p">:</span> <span class="mf">10.</span> <span class="o">**</span> <span class="n">gsmf</span><span class="o">.</span><span class="n">log_gsmf</span><span class="p">(</span><span class="n">logm</span><span class="p">),</span>
                                     <span class="n">logm0</span><span class="p">,</span>
                                     <span class="n">logm1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">density_array</span> <span class="o">=</span> <span class="n">density_array</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logm_per_redshift</span><span class="p">)</span>
        <span class="n">ndensity_array</span> <span class="o">=</span> <span class="n">ndensity_array</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logm_per_redshift</span><span class="p">)</span>

        <span class="n">log_gsmf_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">gsmf</span><span class="o">.</span><span class="n">log_gsmf</span><span class="p">(</span><span class="n">logm</span><span class="p">))</span> <span class="k">for</span> <span class="n">logm</span> <span class="ow">in</span> <span class="n">logm_array</span><span class="p">]])</span>

        <span class="n">zoh_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">mzr</span><span class="o">.</span><span class="n">zoh</span><span class="p">(</span><span class="n">logm</span><span class="p">)</span> <span class="k">for</span> <span class="n">logm</span> <span class="ow">in</span> <span class="n">logm_bins</span><span class="p">]])</span>

        <span class="n">zoh_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">mzr</span><span class="o">.</span><span class="n">zoh</span><span class="p">(</span><span class="n">logm</span><span class="p">)</span> <span class="k">for</span> <span class="n">logm</span> <span class="ow">in</span> <span class="n">logm_array</span><span class="p">]])</span>
        <span class="n">log_sfr_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">sfmr</span><span class="o">.</span><span class="n">logsfr</span><span class="p">(</span><span class="n">logm</span><span class="p">)</span> <span class="k">for</span> <span class="n">logm</span> <span class="ow">in</span> <span class="n">logm_array</span><span class="p">]])</span>

        <span class="n">feh_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">ZOH_to_FeH</span><span class="p">(</span><span class="n">zoh</span><span class="p">)</span> <span class="k">for</span> <span class="n">zoh</span> <span class="ow">in</span> <span class="n">zoh_array</span><span class="o">.</span><span class="n">flatten</span><span class="p">()]])</span>

        <span class="n">feh_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">feh_array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_igimf_corrections</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">feh</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">feh_array</span><span class="o">.</span><span class="n">flatten</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">feh</span> <span class="o">&gt;</span> <span class="mf">1.3</span> <span class="ow">or</span> <span class="n">feh</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">5</span><span class="p">:</span>
                    <span class="n">feh_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">feh_mask</span> <span class="o">=</span> <span class="n">feh_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>

        <span class="n">sfr_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">log_sfr_array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_igimf_corrections</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sfr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">log_sfr_array</span><span class="o">.</span><span class="n">flatten</span><span class="p">()):</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sfr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">3.3</span><span class="p">:</span>
                    <span class="n">sfr_mask</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">sfr_mask</span> <span class="o">=</span> <span class="n">sfr_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">ndensity_array</span><span class="p">,</span> <span class="n">density_array</span><span class="p">,</span> <span class="n">logm_array</span><span class="p">,</span> <span class="n">log_gsmf_array</span><span class="p">,</span> <span class="n">zoh_array</span><span class="p">,</span>
                <span class="n">zoh_bins</span><span class="p">,</span> <span class="n">feh_array</span><span class="p">,</span> <span class="n">feh_mask</span><span class="p">,</span> <span class="n">log_sfr_array</span><span class="p">,</span> <span class="n">sfr_mask</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_correct_sample</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">mass_array</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">log_gsmf_array</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
            <span class="n">zoh_array</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">feh_array</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">sfr_array</span><span class="p">:</span><span class="n">NDArray</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
            <span class="n">mask_array</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span>
               <span class="nb">list</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">NDArray</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Applies SFR corrections for a variant IMF.</span>

<span class="sd">        Applies the corrections from Chruslinska et al. (2020) [1]_,</span>
<span class="sd">        through :class:`sfh.Corrections`, to the SFR, for the variant</span>
<span class="sd">        IGIMF from Jerabkova et al. (2018) [2]_. Requires on a boolean mask</span>
<span class="sd">        ``mask_array`` that filters out SFR-[Fe/H] pairs outside the</span>
<span class="sd">        bounds of the corrections grid from the original paper,</span>
<span class="sd">        :data:`constants.C20_CORRECTIONS_PATH`.</span>

<span class="sd">        Input arrays will have shape</span>
<span class="sd">        (:attr:`n_redshift`, :attr:`logm_per_redshift`) or</span>
<span class="sd">        (:attr:`n_redshift`+2, :attr:`logm_per_redshift`) depending on</span>
<span class="sd">        whether :attr:`force_boundary_redshift` is ``True`` or</span>
<span class="sd">        ``False``, respectively.</span>

<span class="sd">        Output includes lists of arrays with potentially varying</span>
<span class="sd">        lengths. Each list corresponds to a parameter (mass) and</span>
<span class="sd">        each array to a redshift, but containing only parameters for</span>
<span class="sd">        galaxies within the correction boundaries, which can lead</span>
<span class="sd">        to different lengths.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mass_array : NDArray</span>
<span class="sd">            Galaxy stellar masses.</span>
<span class="sd">        log_gsmf_array : NDArray</span>
<span class="sd">            Log GSMF evaluated over ``mass_array``.</span>
<span class="sd">        zoh_array : NDArray</span>
<span class="sd">            Z_OH of each galaxy.</span>
<span class="sd">        feh_array : NDArray</span>
<span class="sd">            [Fe/H] of each galaxy.</span>
<span class="sd">        sfr_array : NDArray</span>
<span class="sd">            SFR of each galaxy.</span>
<span class="sd">        mask_array : NDAray</span>
<span class="sd">            Boolean mask filtering out [Fe/H],SFR pairs outside of the</span>
<span class="sd">            correction boundaries.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mass_list : list</span>
<span class="sd">            List of arrays. Galaxy stellar masses within correction</span>
<span class="sd">            boundaries.</span>
<span class="sd">        log_gsmf_list : list</span>
<span class="sd">            List of arrays. Log GSMF evaluated over ``mass_list``.</span>
<span class="sd">        zoh_list : list</span>
<span class="sd">            List of arrays. Z_OH of each galaxy within correction</span>
<span class="sd">            boundaries.</span>
<span class="sd">        feh_list : list</span>
<span class="sd">            List of arrays. [Fe/H] of each galaxy within correction</span>
<span class="sd">            boundaries.</span>
<span class="sd">        sfr_list : list</span>
<span class="sd">            List of arrays. SFR of each galaxy within correction</span>
<span class="sd">            boundaries.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">mass_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">log_gsmf_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">zoh_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">feh_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">sfr_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">masses</span><span class="p">,</span> <span class="n">log_gsmfs</span><span class="p">,</span> <span class="n">zohs</span><span class="p">,</span> <span class="n">fehs</span><span class="p">,</span> <span class="n">sfrs</span><span class="p">,</span> <span class="n">mask</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mass_array</span><span class="p">,</span> <span class="n">log_gsmf_array</span><span class="p">,</span> <span class="n">zoh_array</span><span class="p">,</span>
                                                             <span class="n">feh_array</span><span class="p">,</span> <span class="n">sfr_array</span><span class="p">,</span> <span class="n">mask_array</span><span class="p">):</span>
            <span class="n">f_masses</span> <span class="o">=</span> <span class="n">masses</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">f_log_gsmfs</span> <span class="o">=</span> <span class="n">log_gsmfs</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">f_zohs</span> <span class="o">=</span> <span class="n">zohs</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">f_fehs</span> <span class="o">=</span> <span class="n">fehs</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">f_sfrs</span> <span class="o">=</span> <span class="n">sfrs</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

            <span class="n">n_samples</span> <span class="o">=</span> <span class="n">f_fehs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">f_sfrs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">f_sfrs</span><span class="p">,</span> <span class="p">(</span><span class="n">n_samples</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">corrections</span> <span class="o">=</span> <span class="n">Corrections</span><span class="p">(</span><span class="n">f_fehs</span><span class="p">,</span> <span class="n">f_sfrs</span><span class="p">)</span>
            <span class="n">corrections</span><span class="o">.</span><span class="n">load_data</span><span class="p">()</span>
            <span class="n">corrs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">corrections</span><span class="o">.</span><span class="n">get_corrections</span><span class="p">())</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">corr_sfrs</span> <span class="o">=</span> <span class="n">f_sfrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">corrs</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="n">corr_sfrs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

            <span class="n">mass_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f_masses</span><span class="p">)</span>
            <span class="n">log_gsmf_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f_log_gsmfs</span><span class="p">)</span>
            <span class="n">zoh_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f_zohs</span><span class="p">)</span>
            <span class="n">feh_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f_fehs</span><span class="p">)</span>
            <span class="n">sfr_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">corr_sfrs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mass_list</span><span class="p">,</span> <span class="n">log_gsmf_list</span><span class="p">,</span> <span class="n">zoh_list</span><span class="p">,</span> <span class="n">feh_list</span><span class="p">,</span> <span class="n">sfr_list</span>

<div class="viewcode-block" id="GalaxyGrid.sample_redshift">
<a class="viewcode-back" href="../../bossa.html#bossa.sampling.GalaxyGrid.sample_redshift">[docs]</a>
    <span class="k">def</span> <span class="nf">sample_redshift</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sample redshifts from the GSMF integrated over mass.</span>

<span class="sd">        Integrating the GSMF over mass yields a star forming mass-over-</span>
<span class="sd">        redshift distribution. A redshift sample is building by dividing</span>
<span class="sd">        the redshift range :attr:`redshift_min`-:attr:`redshift_max`</span>
<span class="sd">        into :attr:`n_redshift` quantiles and assigning each one its</span>
<span class="sd">        mass-weighted average redshift. If</span>
<span class="sd">        :attr:`force_boundary_redshift` is ``True``, the redshift</span>
<span class="sd">        upper and lower limits are also added to the sample.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">redshift_pool</span><span class="p">,</span> <span class="n">redshift_probs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_discrete_redshift_probs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">redshift_min</span><span class="p">,</span>
                                                                      <span class="bp">self</span><span class="o">.</span><span class="n">redshift_max</span><span class="p">,</span>
                                                                      <span class="mi">100</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_redshift</span><span class="p">)</span>

        <span class="c1"># With probabilities calculated, we can generate a</span>
        <span class="c1"># representative sample from which we find n_redshift quantiles.</span>
        <span class="c1"># Repetition is not an issue because only the quantiles are of</span>
        <span class="c1"># interest.</span>
        <span class="n">redshift_choices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">redshift_pool</span><span class="p">,</span>
                                            <span class="n">p</span><span class="o">=</span><span class="n">redshift_probs</span><span class="p">,</span>
                                            <span class="n">size</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mf">1e4</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">n_redshift</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_redshift_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">quantile</span><span class="p">(</span><span class="n">redshift_choices</span><span class="p">,</span>
                                                <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_redshift</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="c1"># Correct for the granularity of the sampling.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_redshift_bins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">redshift_min</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_redshift_bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">redshift_max</span>

        <span class="c1"># Finding uniform quantiles defines which regions of the</span>
        <span class="c1"># redshift range should be equally represented in order</span>
        <span class="c1"># to reproduce the GSMF as well as possible. The quantiles</span>
        <span class="c1"># themselves are represented in the sample by the mass-averaged</span>
        <span class="c1"># redshift of their respective galaxies.</span>
        <span class="n">redshift_i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">force_boundary_redshift</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sample_redshift_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">redshift_min</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sample_redshift_array</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">redshift_max</span>
            <span class="n">redshift_i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">quantile0</span><span class="p">,</span> <span class="n">quantile1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_redshift_bins</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">sample_redshift_bins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">redshift_pool</span><span class="p">,</span> <span class="n">redshift_probs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_discrete_redshift_probs</span><span class="p">(</span><span class="n">quantile0</span><span class="p">,</span>
                                                                          <span class="n">quantile1</span><span class="p">,</span>
                                                                          <span class="mi">100</span><span class="p">)</span>
            <span class="n">massaverage_redshift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">redshift_pool</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">redshift_probs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sample_redshift_array</span><span class="p">[</span><span class="n">redshift_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">massaverage_redshift</span>
            <span class="n">redshift_i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="n">min_redshift_bin_upper_edge</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_redshift_array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                       <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_redshift_array</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">max_redshift_bin_lower_edge</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_redshift_array</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                                       <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_redshift_array</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_redshift_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="n">min_redshift_bin_upper_edge</span><span class="p">],</span>
                                                            <span class="bp">self</span><span class="o">.</span><span class="n">sample_redshift_bins</span><span class="p">,</span>
                                                            <span class="p">[</span><span class="n">max_redshift_bin_lower_edge</span><span class="p">])))</span></div>


    <span class="k">def</span> <span class="nf">_get_sfr_zoh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logm</span><span class="p">,</span> <span class="n">redshift</span><span class="p">):</span>
        <span class="n">sfmr</span> <span class="o">=</span> <span class="n">SFMR</span><span class="p">(</span><span class="n">redshift</span><span class="o">=</span><span class="n">redshift</span><span class="p">,</span>
                    <span class="n">flattening</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sfmr_flattening</span><span class="p">,</span>
                    <span class="n">scatter_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scatter_model</span><span class="p">)</span>
        <span class="n">mzr</span> <span class="o">=</span> <span class="n">MZR</span><span class="p">(</span><span class="n">redshift</span><span class="o">=</span><span class="n">redshift</span><span class="p">,</span>
                  <span class="n">model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mzr_model</span><span class="p">,</span>
                  <span class="n">scatter_model</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scatter_model</span><span class="p">)</span>
        <span class="n">mzr</span><span class="o">.</span><span class="n">set_params</span><span class="p">()</span>

        <span class="n">logsfr</span> <span class="o">=</span> <span class="n">sfmr</span><span class="o">.</span><span class="n">logsfr</span><span class="p">(</span><span class="n">logm</span><span class="p">)</span>
        <span class="n">sfr</span> <span class="o">=</span> <span class="mf">10.</span><span class="o">**</span><span class="n">logsfr</span>
        <span class="n">zoh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mzr</span><span class="o">.</span><span class="n">zoh</span><span class="p">(</span><span class="n">logm</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">feh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ZOH_to_FeH</span><span class="p">(</span><span class="n">zoh</span><span class="p">)</span> <span class="k">for</span> <span class="n">zoh</span> <span class="ow">in</span> <span class="n">zoh</span><span class="p">])</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_igimf_corrections</span><span class="p">:</span>
            <span class="n">corrections</span> <span class="o">=</span> <span class="n">Corrections</span><span class="p">(</span><span class="n">metallicity</span><span class="o">=</span><span class="n">feh</span><span class="p">,</span>
                                      <span class="n">sfr</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">logsfr</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">logsfr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)),</span>
                                                  <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">feh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
            <span class="n">corrections</span><span class="o">.</span><span class="n">load_data</span><span class="p">()</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">corrections</span><span class="o">.</span><span class="n">get_corrections</span><span class="p">())</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">corr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">sfr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="n">sfr</span> <span class="o">*=</span> <span class="mf">10.</span><span class="o">**</span><span class="n">corr</span>

        <span class="k">return</span> <span class="n">sfr</span><span class="p">,</span> <span class="n">zoh</span>

    <span class="k">def</span> <span class="nf">_set_redshift_logm_sampling_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># First 2d bins on the redshift-logm plane are set.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_redshift_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">redshift_min</span><span class="p">,</span>
                                                       <span class="bp">self</span><span class="o">.</span><span class="n">redshift_max</span><span class="p">,</span>
                                                       <span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_side</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_logm_bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logm_min</span><span class="p">,</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">logm_max</span><span class="p">,</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_side</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">sampling_grid_redshift_centers</span> <span class="o">=</span> <span class="n">get_bin_centers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_redshift_bins</span><span class="p">)</span>
        <span class="n">sampling_grid_logm_centers</span> <span class="o">=</span> <span class="n">get_bin_centers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_logm_bins</span><span class="p">)</span>

        <span class="c1"># Initialize the arrays for number density, SFR and Z_O/H</span>
        <span class="c1"># of galaxies at the centers of the redshift-logm bins.</span>
        <span class="n">sampling_grid_ndensity_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_side</span><span class="p">,</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_side</span><span class="p">,</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_samplesize_per_bin</span><span class="p">))</span>
        <span class="n">sampling_grid_sfr_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_side</span><span class="p">,</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_side</span><span class="p">,</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_samplesize_per_bin</span><span class="p">))</span>
        <span class="n">sampling_grid_zoh_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_side</span><span class="p">,</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_side</span><span class="p">,</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_samplesize_per_bin</span><span class="p">))</span>

        <span class="c1"># Fill the three arrays initialized above.</span>
        <span class="c1"># Iterate over redshift bins.</span>
        <span class="k">for</span> <span class="n">row</span><span class="p">,</span> <span class="p">(</span><span class="n">z0</span><span class="p">,</span> <span class="n">z1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">enumerate_bin_edges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_redshift_bins</span><span class="p">):</span>
            <span class="n">redshift</span> <span class="o">=</span> <span class="p">(</span><span class="n">z0</span> <span class="o">+</span> <span class="n">z1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
            <span class="n">gsmf</span> <span class="o">=</span> <span class="n">GSMF</span><span class="p">(</span><span class="n">redshift</span><span class="o">=</span><span class="n">redshift</span><span class="p">,</span>
                        <span class="n">fixed_slope</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gsmf_slope_fixed</span><span class="p">)</span>
            <span class="c1"># Iterate over logm bins.</span>
            <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="p">(</span><span class="n">logm0</span><span class="p">,</span> <span class="n">logm1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">enumerate_bin_edges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_logm_bins</span><span class="p">):</span>
                <span class="c1"># Compute the total number density of galaxies with the</span>
                <span class="c1"># 2d bin.</span>
                <span class="n">ndensity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">quad</span><span class="p">(</span><span class="k">lambda</span> <span class="n">logm</span><span class="p">:</span> <span class="mf">10.</span><span class="o">**</span><span class="n">gsmf</span><span class="o">.</span><span class="n">log_gsmf</span><span class="p">(</span><span class="n">logm</span><span class="p">),</span> <span class="n">logm0</span><span class="p">,</span> <span class="n">logm1</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

                <span class="c1"># Compute the number density of galaxies represented by</span>
                <span class="c1"># each galaxy (logm) to be drawn within the bin.</span>
                <span class="n">ndensity_sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">ndensity</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_samplesize_per_bin</span><span class="p">,</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_samplesize_per_bin</span><span class="p">)</span>

                <span class="c1"># Draw a logm sample, and then for each logm a SFR,</span>
                <span class="c1"># Z_O/H pair. This draw accounts for a normal spread</span>
                <span class="c1"># around the mean values set by the SFMR and MZR.</span>
                <span class="n">logm_sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">uniform</span><span class="p">(</span><span class="n">logm0</span><span class="p">,</span>
                                                <span class="n">logm1</span><span class="p">,</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_samplesize_per_bin</span><span class="p">)</span>
                <span class="n">sfr_sample</span><span class="p">,</span> <span class="n">zoh_sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_sfr_zoh</span><span class="p">(</span><span class="n">logm_sample</span><span class="p">,</span> <span class="n">redshift</span><span class="p">)</span>

                <span class="c1"># Fill the grid arrays.</span>
                <span class="n">sampling_grid_ndensity_centers</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">ndensity_sample</span>
                <span class="n">sampling_grid_sfr_centers</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">sfr_sample</span>
                <span class="n">sampling_grid_zoh_centers</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">zoh_sample</span>

        <span class="c1"># Reorganize the sampling grid arrays into a single array.</span>
        <span class="c1"># First make the redshift and logm arrays the same shape.</span>
        <span class="n">sampling_grid_redshift_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span>
            <span class="n">sampling_grid_logm_centers</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_side</span><span class="p">,</span> <span class="mi">1</span><span class="p">)),</span>
            <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_side</span><span class="p">)</span>
        <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_side</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_side</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">sampling_grid_redshift_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span>
            <span class="n">sampling_grid_redshift_centers</span><span class="p">,</span>
            <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_samplesize_per_bin</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="n">sampling_grid_logm_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span>
            <span class="n">sampling_grid_logm_centers</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_side</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_side</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_side</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">sampling_grid_logm_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span>
            <span class="n">sampling_grid_logm_centers</span><span class="p">,</span>
            <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_samplesize_per_bin</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Now reorganize.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sampling_grid_redshift_centers</span><span class="p">,</span>
                                       <span class="n">sampling_grid_logm_centers</span><span class="p">,</span>
                                       <span class="n">sampling_grid_ndensity_centers</span><span class="p">,</span>
                                       <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">sampling_grid_sfr_centers</span><span class="p">),</span>
                                       <span class="n">sampling_grid_zoh_centers</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_side</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_side</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_samplesize_per_bin</span><span class="p">,</span>
             <span class="mi">5</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Now each line of sampling_grid is a &quot;galaxy&quot; with 5 properties.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid</span> <span class="o">=</span> <span class="n">unstructured_to_structured</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">([(</span><span class="s1">&#39;redshift&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                      <span class="p">(</span><span class="s1">&#39;logm&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                      <span class="p">(</span><span class="s1">&#39;ndensity&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                      <span class="p">(</span><span class="s1">&#39;logsfr&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                      <span class="p">(</span><span class="s1">&#39;zoh&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">)])</span>
        <span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;SAMPLING GRID CREATED WITH SHAPE </span><span class="si">{self.sampling_grid.shape}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># TODO: Initialize arrays in get_grid with the appropriate shape</span>
    <span class="k">def</span> <span class="nf">_scatterless_get_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate the (redshift, mass, metallicity, SFR) grid.</span>

<span class="sd">        For each redshift in :attr:`sample_redshift_array`, samples</span>
<span class="sd">        galaxy stellar masses from :class:`sfh.GSMF`. Star-formation</span>
<span class="sd">        rate and metallicity are assigned through :class:`sfh.SFMR` and</span>
<span class="sd">        :class:`sfh.MZR`, respectively.</span>

<span class="sd">        If :attr:`apply_igimf_corrections` is ``True``, then the</span>
<span class="sd">        corrections to the IMF by Chruslinska et al. (2020) [1]-for the</span>
<span class="sd">        IMF from Jerabkova et al. (2018) [2]_ are applied. Note that the</span>
<span class="sd">        grid of corrections goes from -5 to 1.3 in [Fe/H], and from -3.3</span>
<span class="sd">        to 3.3 in log(SFR). Points outside of this region are removed</span>
<span class="sd">        from the grid if corrections are on.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_sample_masses</span><span class="p">()</span>
        <span class="n">mass_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logm_per_redshift</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">log_gsmf_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logm_per_redshift</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">feh_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logm_per_redshift</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">sfr_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logm_per_redshift</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">feh_mask_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logm_per_redshift</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">sfr_mask_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logm_per_redshift</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">redshift</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_redshift_array</span><span class="p">:</span>
            <span class="p">(</span><span class="n">ndensity_array</span><span class="p">,</span> <span class="n">density_array</span><span class="p">,</span> <span class="n">masses</span><span class="p">,</span> <span class="n">log_gsmfs</span><span class="p">,</span> <span class="n">zohs</span><span class="p">,</span> <span class="n">bin_zohs</span><span class="p">,</span> <span class="n">fehs</span><span class="p">,</span> <span class="n">feh_mask</span><span class="p">,</span>
             <span class="n">sfrs</span><span class="p">,</span> <span class="n">sfr_mask</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sample_galaxies</span><span class="p">(</span><span class="n">redshift</span><span class="p">)</span>
            <span class="n">mass_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mass_array</span><span class="p">,</span> <span class="p">[</span><span class="n">masses</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">log_gsmf_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">log_gsmf_array</span><span class="p">,</span> <span class="n">log_gsmfs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zoh_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zoh_array</span><span class="p">,</span> <span class="n">zohs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">feh_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">feh_array</span><span class="p">,</span> <span class="n">fehs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">sfr_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sfr_array</span><span class="p">,</span> <span class="n">sfrs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">sfr_mask_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sfr_mask_array</span><span class="p">,</span> <span class="n">sfr_mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">feh_mask_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">feh_mask_array</span><span class="p">,</span> <span class="n">feh_mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ndensity_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ndensity_array</span><span class="p">,</span> <span class="n">ndensity_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">density_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">density_array</span><span class="p">,</span> <span class="n">density_array</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zoh_bin_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">zoh_bin_array</span><span class="p">,</span> <span class="n">bin_zohs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">mask_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">feh_mask_array</span><span class="p">,</span> <span class="n">sfr_mask_array</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply_igimf_corrections</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_correct_sample</span><span class="p">(</span><span class="n">mass_array</span><span class="p">,</span>
                                                   <span class="n">log_gsmf_array</span><span class="p">,</span>
                                                   <span class="bp">self</span><span class="o">.</span><span class="n">zoh_array</span><span class="p">,</span>
                                                   <span class="n">feh_array</span><span class="p">,</span>
                                                   <span class="n">sfr_array</span><span class="p">,</span>
                                                   <span class="n">mask_array</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid_array</span> <span class="o">=</span> <span class="n">mass_array</span><span class="p">,</span> <span class="n">log_gsmf_array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zoh_array</span><span class="p">,</span> <span class="n">feh_array</span><span class="p">,</span> <span class="n">sfr_array</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sublist</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_array</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">ssublist</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sublist</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">grid_array</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">ssublist</span><span class="p">,</span>
                                                   <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logm_per_redshift</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">ssublist</span><span class="p">)),</span>
                                                   <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;edge&#39;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">grid_array</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">ssublist</span><span class="p">,</span>
                                                   <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logm_per_redshift</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">ssublist</span><span class="p">)),</span>
                                                   <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;empty&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">grid_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mass_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">log_gsmf_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">zoh_list</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">feh_list</span><span class="p">,</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">sfr_list</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_array</span>

        <span class="n">redshift_grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_redshift_array</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_redshift_array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">redshift_grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">redshift_grid</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">logm_per_redshift</span><span class="p">))</span>
        <span class="n">redshift_grid</span> <span class="o">=</span> <span class="n">redshift_grid</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">redshift_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">grid_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">redshift_grid</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_array</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># TODO: complete scatter_get_sample()</span>
    <span class="c1"># TODO: document scatter_get_sample()</span>
    <span class="k">def</span> <span class="nf">_set_zoh_logsfr_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># First set up the bins to be used when sampling &quot;galaxies&quot;.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_redshift_logm_sampling_grid</span><span class="p">()</span>

        <span class="c1"># Then build the axes over which to sample.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_logsfr_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid</span><span class="p">[:][</span><span class="s1">&#39;logsfr&#39;</span><span class="p">]),</span>
                                                     <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid</span><span class="p">[:][</span><span class="s1">&#39;logsfr&#39;</span><span class="p">]),</span>
                                                     <span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_side</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_zoh_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid</span><span class="p">[:][</span><span class="s1">&#39;zoh&#39;</span><span class="p">]),</span>
                                                  <span class="n">np</span><span class="o">.</span><span class="n">nanmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid</span><span class="p">[:][</span><span class="s1">&#39;zoh&#39;</span><span class="p">]),</span>
                                                  <span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_side</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># And the array which will hold the SFRD computed over those</span>
        <span class="c1"># axes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_logsfrd_overlay</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_side</span><span class="p">,</span>
                                                       <span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_side</span><span class="p">))</span>

        <span class="c1"># Iterate over the axes and fill the SFRD overlay.</span>
        <span class="k">for</span> <span class="n">row</span><span class="p">,</span> <span class="p">(</span><span class="n">zoh0</span><span class="p">,</span> <span class="n">zoh1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">enumerate_bin_edges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_zoh_axis</span><span class="p">):</span>
            <span class="c1"># Get all galaxies from the grid that fall within this</span>
            <span class="c1"># metallicity bin.</span>
            <span class="n">zoh_sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid</span><span class="p">[:][</span><span class="s1">&#39;zoh&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">zoh0</span><span class="p">)</span>
                                            <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid</span><span class="p">[:][</span><span class="s1">&#39;zoh&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">zoh1</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="p">(</span><span class="n">logsfr0</span><span class="p">,</span> <span class="n">logsfr1</span><span class="p">)</span> <span class="ow">in</span> <span class="n">enumerate_bin_edges</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_logsfr_axis</span><span class="p">):</span>
                <span class="c1"># Now all the galaxies that fall within this logSFR bin.</span>
                <span class="n">sfr_sample</span> <span class="o">=</span> <span class="n">zoh_sample</span><span class="p">[(</span><span class="n">zoh_sample</span><span class="p">[:][</span><span class="s1">&#39;logsfr&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">logsfr0</span><span class="p">)</span>
                                        <span class="o">&amp;</span> <span class="p">(</span><span class="n">zoh_sample</span><span class="p">[:][</span><span class="s1">&#39;logsfr&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">logsfr1</span><span class="p">)]</span>

                <span class="c1"># The limits of the SFR corrections grid cause some SFRs</span>
                <span class="c1"># to become NaN. Eliminate those values.</span>
                <span class="n">sfr_sample</span> <span class="o">=</span> <span class="n">sfr_sample</span><span class="p">[</span><span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">sfr_sample</span><span class="p">[:][</span><span class="s1">&#39;logsfr&#39;</span><span class="p">])]</span>

                <span class="c1"># Now get the SFRD represented by each galaxy, from the</span>
                <span class="c1"># galaxy number density it represents, and sum to get</span>
                <span class="c1"># the total SFRD within the metallicity-SFR bin, and</span>
                <span class="c1"># fill the overlay.</span>
                <span class="n">sfrd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sfr_sample</span><span class="p">[:][</span><span class="s1">&#39;ndensity&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mf">10.</span><span class="o">**</span><span class="n">sfr_sample</span><span class="p">[:][</span><span class="s1">&#39;logsfr&#39;</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_logsfrd_overlay</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">sfrd</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="c1"># TODO: have _scatter_get_sample() set the same arrays as _scatterless_get_sample()</span>
    <span class="k">def</span> <span class="nf">_scatter_get_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Compute the SFRD on the metallicity-log SFR plane. This will</span>
        <span class="c1"># set the sampling weights.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_zoh_logsfr_grid</span><span class="p">()</span>

        <span class="c1"># Set the sampling pool for metallicity and log SFR.</span>
        <span class="n">zoh_pool</span> <span class="o">=</span> <span class="n">get_bin_centers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_zoh_axis</span><span class="p">)</span>
        <span class="n">logsfr_pool</span> <span class="o">=</span> <span class="n">get_bin_centers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_logsfr_axis</span><span class="p">)</span>


        <span class="c1"># Set the sampling pool as a 2D array the elements of which</span>
        <span class="c1"># correspond to their indices, then ravel it to a list of index</span>
        <span class="c1"># pairs.</span>
        <span class="n">pool</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_logsfrd_overlay</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">pool</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">pool</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pool</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

        <span class="c1"># Set the weights from the SFRD grid.</span>
        <span class="n">probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="mf">10.</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_logsfrd_overlay</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="n">min_prob</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmin</span><span class="p">(</span><span class="n">probs</span><span class="p">[</span><span class="n">probs</span> <span class="o">!=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>
        <span class="n">probs</span> <span class="o">-=</span> <span class="n">min_prob</span>
        <span class="n">probs</span><span class="p">[</span><span class="n">probs</span> <span class="o">==</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="n">probs</span> <span class="o">/=</span> <span class="n">probs</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="c1"># Randomly sample zoh-SFR pairs through their indices, stored in</span>
        <span class="c1"># pool, weighted by probs. Start by drawing an index from pool.</span>
        <span class="n">sample_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">pool</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="o">=</span><span class="n">probs</span><span class="p">,</span>
                                          <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_redshift</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">logm_per_redshift</span><span class="p">)</span>
        <span class="n">sample_zoh_i</span><span class="p">,</span> <span class="n">sample_logsfr_i</span> <span class="o">=</span> <span class="n">pool</span><span class="p">[</span><span class="n">sample_indices</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
        <span class="n">sample_zoh</span> <span class="o">=</span> <span class="n">zoh_pool</span><span class="p">[</span><span class="n">sample_zoh_i</span><span class="p">]</span>
        <span class="n">sample_logsfr</span> <span class="o">=</span> <span class="n">logsfr_pool</span><span class="p">[</span><span class="n">sample_logsfr_i</span><span class="p">]</span>
        <span class="n">sample</span> <span class="o">=</span> <span class="p">[[</span><span class="n">zoh</span><span class="p">,</span> <span class="n">logsfr</span><span class="p">]</span> <span class="k">for</span> <span class="n">zoh</span><span class="p">,</span> <span class="n">logsfr</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sample_zoh</span><span class="p">,</span> <span class="n">sample_logsfr</span><span class="p">)]</span>
        <span class="n">sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;zoh&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;logsfr&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">)])</span>

        <span class="c1"># Now iterate over the sample to complete it with redshifts.</span>
        <span class="n">sample_redshift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sample_zoh</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">galaxy</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sample</span><span class="p">):</span>
            <span class="n">zoh</span><span class="p">,</span> <span class="n">logsfr</span> <span class="o">=</span> <span class="n">galaxy</span>

            <span class="c1"># Search for the zoh-logsfr bin in which this galaxy falls.</span>
            <span class="n">zoh_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_zoh_axis</span><span class="p">,</span> <span class="n">zoh</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
            <span class="n">zoh_bin0</span><span class="p">,</span> <span class="n">zoh_bin1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_zoh_axis</span><span class="p">[</span><span class="n">zoh_i</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">zoh_i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">logsfr_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_logsfr_axis</span><span class="p">,</span> <span class="n">logsfr</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
            <span class="n">logsfr_bin0</span><span class="p">,</span> <span class="n">logsfr_bin1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid_logsfr_axis</span><span class="p">[</span><span class="n">logsfr_i</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="n">logsfr_i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Get the redshifts of the galaxies within this bin.</span>
            <span class="n">logsfr_bin_sample</span> <span class="o">=</span> <span class="n">sample</span><span class="p">[(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid</span><span class="p">[:][</span><span class="s1">&#39;logsfr&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">logsfr_bin0</span><span class="p">)</span>
                                    <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_grid</span><span class="p">[:][</span><span class="s1">&#39;logsfr&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">logsfr_bin1</span><span class="p">)]</span>
            <span class="n">zoh_bin_sample</span> <span class="o">=</span> <span class="n">logsfr_bin_sample</span><span class="p">[(</span><span class="n">logsfr_bin_sample</span><span class="p">[:][</span><span class="s1">&#39;zoh&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">zoh_bin0</span><span class="p">)</span>
                                               <span class="o">&amp;</span> <span class="p">(</span><span class="n">logsfr_bin_sample</span><span class="p">[:][</span><span class="s1">&#39;zoh&#39;</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">zoh_bin1</span><span class="p">)]</span>
            <span class="n">redshift_bin_sample</span> <span class="o">=</span> <span class="n">zoh_bin_sample</span><span class="p">[:][</span><span class="s1">&#39;redshift&#39;</span><span class="p">]</span>

            <span class="c1"># Use the redshift distribution in the bin to draw a</span>
            <span class="c1"># redshift for this galaxy. Here only</span>
            <span class="n">probs</span><span class="p">,</span> <span class="n">redshift_edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">redshift_bin_sample</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
            <span class="n">redshift_pool</span> <span class="o">=</span> <span class="n">get_bin_centers</span><span class="p">(</span><span class="n">redshift_edges</span><span class="p">)</span>
            <span class="n">sample_redshift</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">redshift_pool</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">probs</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Complete the sample.</span>
        <span class="n">sample</span> <span class="o">=</span> <span class="p">[[</span><span class="n">zoh</span><span class="p">,</span> <span class="n">logsfr</span><span class="p">,</span> <span class="n">redshift</span><span class="p">]</span> <span class="k">for</span> <span class="n">zoh</span><span class="p">,</span> <span class="n">logsfr</span><span class="p">,</span> <span class="n">redshift</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sample_zoh</span><span class="p">,</span>
                                                                           <span class="n">sample_logsfr</span><span class="p">,</span>
                                                                           <span class="n">sample_redshift</span><span class="p">)]</span>
        <span class="n">sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sample</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;zoh&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;logsfr&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;redshift&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">)])</span>

<div class="viewcode-block" id="GalaxyGrid.get_sample">
<a class="viewcode-back" href="../../bossa.html#bossa.sampling.GalaxyGrid.get_sample">[docs]</a>
    <span class="k">def</span> <span class="nf">get_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">scatter_model</span> <span class="o">==</span> <span class="s1">&#39;normal&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scatter_get_sample</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_scatterless_get_sample</span><span class="p">()</span></div>


<div class="viewcode-block" id="GalaxyGrid.save_grid">
<a class="viewcode-back" href="../../bossa.html#bossa.sampling.GalaxyGrid.save_grid">[docs]</a>
    <span class="k">def</span> <span class="nf">save_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save :attr:`grid_array` to disk.&quot;&quot;&quot;</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Redshift&#39;</span><span class="p">,</span> <span class="s1">&#39;Log(Mgal/Msun)&#39;</span><span class="p">,</span> <span class="s1">&#39;Log(Number density [Mpc-3 Msun-1])&#39;</span><span class="p">,</span>
                   <span class="s1">&#39;Log(SFR [Msun yr-1])&#39;</span><span class="p">,</span> <span class="s1">&#39;12+log(O/H)&#39;</span><span class="p">,</span> <span class="s1">&#39;[Fe/H]&#39;</span><span class="p">]</span>
        <span class="n">grid_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid_array</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">)</span>
        <span class="n">grid_df</span><span class="o">.</span><span class="n">to_pickle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">save_path</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="SimpleBinaryPopulation">
<a class="viewcode-back" href="../../bossa.html#bossa.sampling.SimpleBinaryPopulation">[docs]</a>
<span class="k">class</span> <span class="nc">SimpleBinaryPopulation</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a sample of zero-age main sequence binaries.</span>

<span class="sd">    For a given redshift, star formation rate (SFR) and [Fe/H], generate a sample of multiple systems with component</span>
<span class="sd">    masses between m_min and m_max, and up to max_comp_number companions. Each system is represented by the parameters</span>
<span class="sd">    of its innermost binaries and its total corresponding mass, including all companions. Masses are drawn from the</span>
<span class="sd">    integrated galaxy-wide initial mass function (IGIMF) and orbital parameters from correlated distributions.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    save_path</span>
<span class="sd">    redshift : float</span>
<span class="sd">        Redshift at which to generate the sample.</span>
<span class="sd">    sfr : float</span>
<span class="sd">        SFR for which to generate the samples, in Msun yr-1.</span>
<span class="sd">    feh : float</span>
<span class="sd">        [Fe/H] metallicity for which to generate the sample.</span>
<span class="sd">    z_abs : float</span>
<span class="sd">        Metallicity feh in Z.</span>
<span class="sd">    m_min : float</span>
<span class="sd">        Minimum sampled mass.</span>
<span class="sd">    m_max : float</span>
<span class="sd">        Maximum sampled mass.</span>
<span class="sd">    max_comp_number : int</span>
<span class="sd">        Maximum number of companions.</span>
<span class="sd">    poolsize : int</span>
<span class="sd">        Size of the pool from which masses are drawn, without repetition.</span>
<span class="sd">    col_n : int</span>
<span class="sd">        Number of columns (parameters) defining a binary.</span>
<span class="sd">    sample : numpy array</span>
<span class="sd">        (n, col_n) array of n binaries, each defined by a set of col_n parameters.</span>
<span class="sd">    sample_mass : float</span>
<span class="sd">        Total sample mass, including all system components.</span>
<span class="sd">    qe_max_tries : int</span>
<span class="sd">        Maximum number of attempts to draw a valid system for a given primary mass, orbital period pair.</span>
<span class="sd">    galaxy_descriptor : str</span>
<span class="sd">        String describing the sampled population, to be appended to the sample filename.</span>
<span class="sd">    m1_min : float</span>
<span class="sd">        Minimum primary mass allowed.</span>
<span class="sd">    lowmass_powerlaw_index : float</span>
<span class="sd">        Index of the power law from which &lt; 0.8 Msun mass options are drawn.</span>
<span class="sd">    lowmass_powerlaw_norm : float</span>
<span class="sd">        Norm of the power law from which &lt; 0.8 Msun mass options are drawn.</span>
<span class="sd">    igimf_arr : numpy array</span>
<span class="sd">        Array of &gt;= 0.8 Msun mass options drawn from the IGIMF.</span>
<span class="sd">    sampling_pool : numpy array</span>
<span class="sd">        Complete pool of mass options for sampling.</span>
<span class="sd">    prioritize_high_masses : bool</span>
<span class="sd">        Whether to bias the sampler towards drawing higher masses first or not.</span>
<span class="sd">    print_progress : bool</span>
<span class="sd">        Whether to print progress updates (percentage, elapsed time, remaining time) to stdout or not.</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    set_sampling_pool()</span>
<span class="sd">        Compute the array of mass options for sampling.</span>
<span class="sd">    get_sample()</span>
<span class="sd">        Generate full sample, save parameters to sample and the total mass to sample_mass.</span>
<span class="sd">    save_sample()</span>
<span class="sd">        Save sample to a parquet file at _save_path.</span>

<span class="sd">    Warns</span>
<span class="sd">    -----</span>
<span class="sd">    UserWarning</span>
<span class="sd">        If get_sample() is run before set_sampling_pool().</span>
<span class="sd">    UserWarning</span>
<span class="sd">        If sample is empty when save_sample() is called.</span>

<span class="sd">    Warnings</span>
<span class="sd">    --------</span>
<span class="sd">    For a pool of poolsize possible masses, a sample of &lt;~ 0.7*poolsize/2 binaries is generated. This is because two</span>
<span class="sd">    mass arrays are generated, one above and one below 0.8 Msun, containing poolsize/2 elements each; and because as the</span>
<span class="sd">    sampling pool is exhausted, remaining possible multiples tend to be invalid (fail the tolerance test in class</span>
<span class="sd">    ZAMSSystemGenerator), and the sampling stops after a certain number of consecutive failed iterations.</span>

<span class="sd">    See Also</span>
<span class="sd">    -------</span>
<span class="sd">    zams.ZAMSSystemGenerator</span>
<span class="sd">        Sampling of an individual multiple system.</span>
<span class="sd">    zams.MultipleFraction</span>
<span class="sd">        Sampling of the number of companions.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This sampler generates a population that simultaneously follows to correlated orbital parameter distributions by</span>
<span class="sd">    Moe &amp; Di Stefano (2017) [3]_ and the IGIMF by Jerabkova et al. (2018) [2]_. The sample is only representative of the IGIMF</span>
<span class="sd">    between 0.8 and 150 Msun, because the sampling of the primary mass m1 is restricted to this range in order as per</span>
<span class="sd">    the minimum mass sampled by the orbital parameter distributions. Components with masses between 0.08 and 0.8 Msun</span>
<span class="sd">    appear as companions, but they will not reproduce the IGIMF below 0.8 Msun as all &lt; 0.8 Msun primaries and their</span>
<span class="sd">    companions will be missing. On the other hand, because for the mass ratio 0.1 &lt;= q &lt;= 1.0, the range between 0.8</span>
<span class="sd">    and 150 Msun should be complete to good approximation, as discussed in OUR WORK.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [3] Moe, M., Di Stefano, R. (2017). Mind Your Ps and Qs: The Interrelation between Period (P) and Mass-ratio (Q)</span>
<span class="sd">        Distributions of Binary Stars. ApJS, 230(2), 55. doi:10.3847/1538-4365/aa6fb6</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">inner_binary_sample_columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Mass_ZAMS1_Found&#39;</span><span class="p">,</span>  <span class="c1">#0</span>
                                   <span class="s1">&#39;Mass_ZAMS1_Choice&#39;</span><span class="p">,</span>  <span class="c1">#1</span>
                                   <span class="s1">&#39;RelDev_Mass_ZAMS1&#39;</span><span class="p">,</span>  <span class="c1">#2</span>
                                   <span class="s1">&#39;Mass_ZAMS2_Found&#39;</span><span class="p">,</span>  <span class="c1">#3</span>
                                   <span class="s1">&#39;Mass_ZAMS2_Choice&#39;</span><span class="p">,</span>  <span class="c1">#4</span>
                                   <span class="s1">&#39;RelDev_Mass_ZAMS2&#39;</span><span class="p">,</span>  <span class="c1">#5</span>
                                   <span class="s1">&#39;MassRatioFound_ZAMS&#39;</span><span class="p">,</span>  <span class="c1">#6</span>
                                   <span class="s1">&#39;MassRatioChoice_ZAMS&#39;</span><span class="p">,</span>  <span class="c1">#7</span>
                                   <span class="s1">&#39;LogOrbitalPeriod_ZAMS&#39;</span><span class="p">,</span>  <span class="c1">#8</span>
                                   <span class="s1">&#39;Eccentricity_ZAMS&#39;</span><span class="p">,</span>  <span class="c1">#9</span>
                                   <span class="s1">&#39;CompanionNumber&#39;</span><span class="p">,</span>  <span class="c1">#10</span>
                                   <span class="s1">&#39;SystemMass&#39;</span><span class="p">]</span> <span class="c1">#11</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Column titles for the 12 parameters identifying each inner binary.&quot;&quot;&quot;</span>
    <span class="n">outer_pair_columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Mass_ZAMS3_Found&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;Mass_ZAMS3_Choice&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;LogOrbitalPeriod_ZAMS3&#39;</span><span class="p">,</span>
                          <span class="s1">&#39;Eccentricity_ZAMS3&#39;</span><span class="p">]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Columns saved for each further outer companion.&quot;&quot;&quot;</span>


    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">redshift</span><span class="p">,</span> <span class="n">sfr</span><span class="p">,</span> <span class="n">feh</span><span class="p">,</span> <span class="n">m_min</span><span class="p">,</span> <span class="n">m_max</span><span class="p">,</span> <span class="n">max_comp_number</span><span class="p">,</span> <span class="n">poolsize</span><span class="p">,</span> <span class="n">qe_max_tries</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">only_binaries</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">invariant_imf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">correlated_orbital_parameters</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">galaxy_descriptor</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">parent_logger</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">prioritize_high_masses</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">print_progress</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">save_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        redshift : float</span>
<span class="sd">            Redshift at which to generate the sample.</span>
<span class="sd">        sfr : float</span>
<span class="sd">            SFR for which to generate the samples, in Msun yr-1.</span>
<span class="sd">        feh : float</span>
<span class="sd">            [Fe/H] metallicity for which to generate the sample.</span>
<span class="sd">        m_min : float</span>
<span class="sd">            Minimum sampled mass.</span>
<span class="sd">        m_max : float</span>
<span class="sd">            Maximum sampled mass.</span>
<span class="sd">        max_comp_number : int</span>
<span class="sd">            Maximum number of companions.</span>
<span class="sd">        poolsize : int</span>
<span class="sd">            Size of the pool from which masses are drawn, without repetition.</span>
<span class="sd">        qe_max_tries : int, default : 1</span>
<span class="sd">            Maximum number of attempts to draw a valid system for a given primary mass, orbital period pair.</span>
<span class="sd">        galaxy_descriptor : str, default : &#39;&#39;</span>
<span class="sd">            String describing the sampled population, to be appended to the sample filename.</span>
<span class="sd">        parent_logger : logging Logger, default : None</span>
<span class="sd">            Logger of the class or module from which this class was instantiated.</span>
<span class="sd">        prioritize_high_masses : bool, default : False</span>
<span class="sd">            Whether to bias the sampler towards drawing higher masses first or not.</span>
<span class="sd">        print_progress : bool, default : True</span>
<span class="sd">            Whether to print progress updates (percentage, elapsed time, remaining time) to stdout or not.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">redshift</span> <span class="o">=</span> <span class="n">redshift</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sfr</span> <span class="o">=</span> <span class="n">sfr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">feh</span> <span class="o">=</span> <span class="n">feh</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z_abs</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="n">feh</span> <span class="o">*</span> <span class="n">Z_SUN</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m_min</span> <span class="o">=</span> <span class="n">m_min</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m_max</span> <span class="o">=</span> <span class="n">m_max</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_comp_number</span> <span class="o">=</span> <span class="n">max_comp_number</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">only_binaries</span> <span class="o">=</span> <span class="n">only_binaries</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invariant_imf</span> <span class="o">=</span> <span class="n">invariant_imf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">correlated_orbital_parameters</span> <span class="o">=</span> <span class="n">correlated_orbital_parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">poolsize</span> <span class="o">=</span> <span class="n">poolsize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">col_n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_columns</span><span class="p">)</span>
        <span class="c1">#self.sample_mass = 0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qe_max_tries</span> <span class="o">=</span> <span class="n">qe_max_tries</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">galaxy_descriptor</span> <span class="o">=</span> <span class="n">galaxy_descriptor</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m1_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="mf">0.8</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lowmass_powerlaw_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lowmass_powerlaw_norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">igimf_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampling_pool</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">poolsize</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prioritize_high_masses</span> <span class="o">=</span> <span class="n">prioritize_high_masses</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">print_progress</span> <span class="o">=</span> <span class="n">print_progress</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_m1_draws</span> <span class="o">=</span> <span class="mi">1000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_logger</span><span class="p">(</span><span class="n">parent_logger</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_dir</span> <span class="o">=</span> <span class="n">save_dir</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">pairs_table_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Path to the orbital parameter sampling table.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">correlated_orbital_parameters</span><span class="p">:</span>
            <span class="n">pairs_table_path</span> <span class="o">=</span> <span class="n">BINARIES_CORRELATED_TABLE_PATH</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pairs_table_path</span> <span class="o">=</span> <span class="n">BINARIES_UNCORRELATED_TABLE_PATH</span>
        <span class="k">return</span> <span class="n">pairs_table_path</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">save_path</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Path to which to save the sample as a parquet file.&quot;&quot;&quot;</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;z=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">redshift</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">_feh=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">feh</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">_logsfr=</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sfr</span><span class="p">)</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">_&#39;</span> \
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">galaxy_descriptor</span><span class="si">}</span><span class="s1">_logpool=</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">poolsize</span><span class="p">)</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">_igimf_zams_sample.parquet&#39;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">save_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">IGIMF_ZAMS_DIR_PATH</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">save_dir</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
            <span class="n">save_path</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">save_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">IGIMF_ZAMS_DIR_PATH</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">save_path</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">sample_columns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sample column titles.&quot;&quot;&quot;</span>
        <span class="n">outer_pair_columns</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">cp_order</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_comp_number</span><span class="o">+</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outer_pair_columns</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outer_pair_columns</span><span class="p">):</span>
                <span class="n">columns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;3&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">cp_order</span><span class="p">))</span>
            <span class="n">outer_pair_columns</span> <span class="o">+=</span> <span class="n">columns</span>
        <span class="n">sample_columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inner_binary_sample_columns</span> <span class="o">+</span> <span class="n">outer_pair_columns</span>
        <span class="k">return</span> <span class="n">sample_columns</span>

    <span class="k">def</span> <span class="nf">_get_logger</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent_logger</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create and return a class logger, as a child of a parent logger if provided.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">parent_logger</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">loggername</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">])</span>
            <span class="n">log_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">LOG_PATH</span><span class="p">,</span> <span class="n">loggername</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1">-%m-%Y_%H:%M:%S.log&#39;</span><span class="p">))</span>
            <span class="n">log_path</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">logger</span> <span class="o">=</span> <span class="n">create_logger</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">loggername</span><span class="p">,</span> <span class="n">fpath</span><span class="o">=</span><span class="n">log_path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loggername</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">parent_logger</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">])</span>
            <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">loggername</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">logger</span>

    <span class="k">def</span> <span class="nf">_lowmass_powerlaw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Evaluate the low-mass power law at m.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">powerlaw</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lowmass_powerlaw_norm</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lowmass_powerlaw_index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_imf_random_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m_min</span><span class="p">,</span> <span class="n">m_max</span><span class="p">,</span> <span class="n">samplesize</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate a random sampling of the IMF of size samplesize, between m_min and m_max.</span>

<span class="sd">        Compute the values imf_arr of the IMF at masses imf_mass_arr, then take a random sample randomsample from</span>
<span class="sd">        imf_mass_arr with imf_arr as weights.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        m_min : float</span>
<span class="sd">            Minimum mass for sampling</span>
<span class="sd">        m_max : float</span>
<span class="sd">            Maximum mass for sampling.</span>
<span class="sd">        samplesize : float</span>
<span class="sd">            Size of sample.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        imf_mass_arr : numpy array</span>
<span class="sd">            Masses on which the IGIMF was computed.</span>
<span class="sd">        imf_arr : numpy array</span>
<span class="sd">            IGIMF values computed on imf_mass_arr.</span>
<span class="sd">        randomsample : numpy array</span>
<span class="sd">            Mass sample from the IGIMF.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Starting IGIMF random sampling: n=</span><span class="si">{</span><span class="n">samplesize</span><span class="si">}</span><span class="s1">, mmin=</span><span class="si">{</span><span class="n">m_min</span><span class="si">}</span><span class="s1"> Msun, mmax = </span><span class="si">{</span><span class="n">m_max</span><span class="si">}</span><span class="s1"> Msun.&#39;</span><span class="p">)</span>
        <span class="n">time0</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">invariant_imf</span><span class="p">:</span>
            <span class="n">total_star_mass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sfr</span> <span class="o">*</span> <span class="mf">1e7</span>
            <span class="n">imf</span> <span class="o">=</span> <span class="n">Star</span><span class="p">(</span><span class="n">total_star_mass</span><span class="p">,</span> <span class="n">feh</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">feh</span><span class="p">,</span> <span class="n">invariant</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">imf</span><span class="o">.</span><span class="n">get_mmax_k</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">imf</span> <span class="o">=</span> <span class="n">IGIMF</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sfr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">feh</span><span class="p">)</span>
            <span class="n">imf</span><span class="o">.</span><span class="n">set_clusters</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;IMF created with logSFR = </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sfr</span><span class="p">)</span><span class="si">}</span><span class="s1"> Msun yr-1 and [Fe/H] = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">feh</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">randomsampler</span> <span class="o">=</span> <span class="n">RandomSampling</span><span class="p">(</span><span class="n">imf</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Created random sampler.&#39;</span><span class="p">)</span>
        <span class="n">randomsampler</span><span class="o">.</span><span class="n">compute_imf</span><span class="p">()</span>
        <span class="n">randomsample</span> <span class="o">=</span> <span class="n">randomsampler</span><span class="o">.</span><span class="n">get_sample</span><span class="p">(</span><span class="n">m_min</span><span class="p">,</span> <span class="n">m_max</span><span class="p">,</span> <span class="n">samplesize</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">imf_mass_arr</span> <span class="o">=</span> <span class="n">randomsampler</span><span class="o">.</span><span class="n">discretization_masses</span>
        <span class="n">imf_arr</span> <span class="o">=</span> <span class="n">randomsampler</span><span class="o">.</span><span class="n">discrete_imf</span>

        <span class="n">time1</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">time0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;IMF random sampling completed in </span><span class="si">{</span><span class="n">time1</span><span class="si">:</span><span class="s1">.6f</span><span class="si">}</span><span class="s1"> s.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">imf_mass_arr</span><span class="p">,</span> <span class="n">imf_arr</span><span class="p">,</span> <span class="n">randomsample</span>

    <span class="k">def</span> <span class="nf">_low_high_mass_area_diff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lowmass_index</span><span class="p">,</span> <span class="n">highmass_spline</span><span class="p">,</span> <span class="n">highmass_area</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the difference in area between the power law IMF at low masses and the IGIMF at high masses.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">lowmass_index</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">lowmass_index</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">area_diff</span> <span class="o">=</span> <span class="mf">1e7</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">lowmass_norm</span> <span class="o">=</span> <span class="n">highmass_spline</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m1_min</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">m1_min</span> <span class="o">**</span> <span class="n">lowmass_index</span>
            <span class="n">lowmass_area</span> <span class="o">=</span> <span class="n">lowmass_norm</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m1_min</span> <span class="o">**</span> <span class="p">(</span><span class="n">lowmass_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">m_min</span> <span class="o">**</span> <span class="p">(</span><span class="n">lowmass_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="n">lowmass_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">area_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">highmass_area</span> <span class="o">-</span> <span class="n">lowmass_area</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">area_diff</span>

    <span class="k">def</span> <span class="nf">_set_lowmass_powerlaw</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">highmass_mass_arr</span><span class="p">,</span> <span class="n">highmass_igimf_arr</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets the power law IMF at low masses such that its area is the same as the IGIMF&#39;s at high masses.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Fitting IMF m &lt; 0.8 power law.&#39;</span><span class="p">)</span>
        <span class="n">time0</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
        <span class="n">hmass_spline</span> <span class="o">=</span> <span class="n">UnivariateSpline</span><span class="p">(</span><span class="n">highmass_mass_arr</span><span class="p">,</span> <span class="n">highmass_igimf_arr</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">hmass_area</span> <span class="o">=</span> <span class="n">hmass_spline</span><span class="o">.</span><span class="n">integral</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m1_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m_max</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lowmass_powerlaw_index</span> <span class="o">=</span> <span class="n">fmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_low_high_mass_area_diff</span><span class="p">,</span>
                                           <span class="n">x0</span><span class="o">=-</span><span class="mf">0.3</span><span class="p">,</span>
                                           <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">hmass_spline</span><span class="p">,</span> <span class="n">hmass_area</span><span class="p">),</span>
                                           <span class="n">disp</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lowmass_powerlaw_norm</span> <span class="o">=</span> <span class="n">hmass_spline</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m1_min</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">m1_min</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">lowmass_powerlaw_index</span>
        <span class="n">time1</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">time0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Power law fitted with a = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">lowmass_powerlaw_index</span><span class="si">}</span><span class="s1">,&#39;</span> \
                          <span class="sa">f</span><span class="s1">&#39;k = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">lowmass_powerlaw_norm</span><span class="si">}</span><span class="s1"> in </span><span class="si">{</span><span class="n">time1</span><span class="si">:</span><span class="s1">.6f</span><span class="si">}</span><span class="s1"> s.&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="SimpleBinaryPopulation.set_sampling_pool">
<a class="viewcode-back" href="../../bossa.html#bossa.sampling.SimpleBinaryPopulation.set_sampling_pool">[docs]</a>
    <span class="k">def</span> <span class="nf">set_sampling_pool</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the mass pool from which to draw the sample.</span>

<span class="sd">        Set the mass pool from which to draw the final sample as a random sampling of poolsize/2 from the IGIMF, above</span>
<span class="sd">        m1_min; and of a power law with the same area between m_min and m1_min as the IGIMF between m1_min and m_max,</span>
<span class="sd">        below m1_min.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Because the primary mass sampling is limited to m1 &gt;= m1_min, in any case the IMF cannot be reproduced in the</span>
<span class="sd">        m &lt; m1_min region; at the same time, an IMF at &lt; m1_min is still necessary for the sampling of light companions.</span>
<span class="sd">        Thus the IMF for m &lt; m1_min is defined to be a power law continuous with the IGIMF at m &gt;= m1_min, with a slope</span>
<span class="sd">        such that its area below m1_min is the same as that of the IGIMF above. This choice is made in order to conform</span>
<span class="sd">        with the drawing of the same amount poolsize/2 of masses from both sides of m1_min.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Setting sampling pool...&#39;</span><span class="p">)</span>
        <span class="n">time0</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
        <span class="n">hmass_pool_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">poolsize</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">lmass_pool_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">poolsize</span> <span class="o">-</span> <span class="n">hmass_pool_size</span><span class="p">)</span>
        <span class="n">imf_mass_arr</span><span class="p">,</span> <span class="n">imf_arr</span><span class="p">,</span> <span class="n">hmass_pool</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_imf_random_sample</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m1_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m_max</span><span class="p">,</span> <span class="n">hmass_pool_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Got m &gt; 0.8 sampling pool.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">igimf_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">imf_mass_arr</span><span class="p">,</span> <span class="n">imf_arr</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_lowmass_powerlaw</span><span class="p">(</span><span class="n">imf_mass_arr</span><span class="p">,</span> <span class="n">imf_arr</span><span class="p">)</span>  <span class="c1"># the IMF sample sets the equal area constraint</span>
        <span class="n">lmass_mass_options</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m1_min</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">lmass_pool_size</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">lmass_option_probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_lowmass_powerlaw</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">lmass_mass_options</span><span class="p">])</span>
        <span class="n">lmass_option_probs</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">lmass_option_probs</span><span class="p">)</span>

        <span class="n">lmass_pool</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">lmass_mass_options</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">lmass_option_probs</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">lmass_pool_size</span><span class="p">)</span>
        <span class="n">lmass_pool</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">lmass_pool</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Got m &lt; 0.8 sampling pool.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sampling_pool</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">lmass_pool</span><span class="p">,</span> <span class="n">hmass_pool</span><span class="p">))</span>
        <span class="n">time1</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">time0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Sampling pool set in </span><span class="si">{</span><span class="n">time1</span><span class="si">:</span><span class="s1">.6f</span><span class="si">}</span><span class="s1"> s.&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="SimpleBinaryPopulation.get_sample">
<a class="viewcode-back" href="../../bossa.html#bossa.sampling.SimpleBinaryPopulation.get_sample">[docs]</a>
    <span class="k">def</span> <span class="nf">get_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate the binary sample.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampling_pool</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Sampling pool not set up. Please run set_sampling_pool() first.&#39;</span><span class="p">)</span>
            <span class="k">return</span>



        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Getting sample...&#39;</span><span class="p">)</span>
        <span class="n">time0</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>

        <span class="c1"># The ZAMSSystemGenerator class samples the parameters of individual binaries, with the masses being taken from</span>
        <span class="c1"># imf_array. The innermost pair is returned in the case of higher order multiples, but all companion masses are</span>
        <span class="c1"># removed from imf_array and taken into account in the total system mass.</span>
        <span class="n">systemgenerator</span> <span class="o">=</span> <span class="n">ZAMSSystemGenerator</span><span class="p">(</span><span class="n">imf_array</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sampling_pool</span><span class="p">,</span>
                                              <span class="n">pairs_table_path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pairs_table_path</span><span class="p">,</span>
                                              <span class="n">qe_max_tries</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qe_max_tries</span><span class="p">,</span> <span class="n">dmcomp_tol</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
                                              <span class="n">parent_logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Started ZAMSSystemGenerator with binaries_table_path=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">pairs_table_path</span><span class="si">}</span><span class="s1">,&#39;</span> \
                          <span class="sa">f</span><span class="s1">&#39;eq_max_tries = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">qe_max_tries</span><span class="si">}</span><span class="s1"> and dm2tol = </span><span class="si">{</span><span class="mf">0.05</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
        <span class="n">systemgenerator</span><span class="o">.</span><span class="n">setup_sampler</span><span class="p">()</span>

        <span class="c1"># The MultipleFraction class provides the probability distribution of the number of companions as a function of</span>
        <span class="c1"># primary mass.</span>
        <span class="n">multiple_fractions</span> <span class="o">=</span> <span class="n">MultipleFraction</span><span class="p">(</span><span class="n">mmin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">m_min</span><span class="p">,</span> <span class="n">mmax</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">m_max</span><span class="p">,</span>
                                              <span class="n">nmax</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_comp_number</span><span class="p">,</span>
                                              <span class="n">only_binaries</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">only_binaries</span><span class="p">)</span>
        <span class="n">multiple_fractions</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="n">ncomp_options</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_comp_number</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Starting sampling loop.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">col_n</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">sample_list</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_progress</span><span class="p">:</span>
            <span class="n">prev_progress</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">progress_update_step</span> <span class="o">=</span> <span class="mf">0.01</span>
            <span class="n">iteration_counter</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">progress</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">prog_norm</span> <span class="o">=</span> <span class="n">systemgenerator</span><span class="o">.</span><span class="n">m1array_n</span>
        <span class="n">fail_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
        <span class="n">iteration_timer</span> <span class="o">=</span> <span class="n">start_time</span>
        <span class="c1"># systemgenerator keeps track of the remaining number of m1 options as m1array_n.</span>
        <span class="k">while</span> <span class="n">systemgenerator</span><span class="o">.</span><span class="n">m1array_n</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># The code below draws m1 as an index of imf_array, randomly taken from the available range.</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">prioritize_high_masses</span><span class="p">:</span>
                <span class="n">m1choice_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">systemgenerator</span><span class="o">.</span><span class="n">m1array_n</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Alternatively, the code below prioritizes drawing the highest available masses first.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">m1ops</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">systemgenerator</span><span class="o">.</span><span class="n">m1array_n</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">systemgenerator</span><span class="o">.</span><span class="n">m1array_n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">m1ps</span> <span class="o">=</span> <span class="n">m1ops</span><span class="o">/</span><span class="n">m1ops</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">m1ps</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">m1choice_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">m1ops</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">m1ps</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># All binary parameters are taken from a table structured in PyTable Groups, for each primary mass; and</span>
            <span class="c1"># Tables within Groups, for each orbital period. Table lines contain equiprobable mass ratio, eccentricity</span>
            <span class="c1"># pairs.</span>
            <span class="n">systemgenerator</span><span class="o">.</span><span class="n">open_m1group</span><span class="p">(</span><span class="n">m1choice_i</span><span class="p">)</span>

            <span class="c1"># m1choice is drawn from imf_array, while m1_table is its closest counterpart in m1group. For m1group the</span>
            <span class="c1"># mean number of companions is calculated and defines the probability distribution from which a companion</span>
            <span class="c1"># number is drawn for this primary.</span>
            <span class="n">ncomp_mean</span> <span class="o">=</span> <span class="n">multiple_fractions</span><span class="o">.</span><span class="n">ncomp_mean</span><span class="p">(</span><span class="n">systemgenerator</span><span class="o">.</span><span class="n">m1_table</span><span class="p">)</span>
            <span class="n">nmean_probs</span> <span class="o">=</span> <span class="n">multiple_fractions</span><span class="o">.</span><span class="n">prob</span><span class="p">(</span><span class="n">ncomp_mean</span><span class="p">,</span> <span class="n">ncomp_options</span><span class="p">)</span>
            <span class="n">ncomp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">ncomp_options</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="n">nmean_probs</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># All binary parameters must be taken from the referred to table, but masses are drawn from imf_array. A</span>
            <span class="c1"># system is only accepted if the array and table masses pass a tolerance test. If they do not, inner_binary</span>
            <span class="c1"># is an empty list, and system mass is 0.</span>
            <span class="c1">#inner_binary, system_mass = systemgenerator.sample_system(ncomp=ncomp)</span>
            <span class="n">sampled_pairs</span> <span class="o">=</span> <span class="n">systemgenerator</span><span class="o">.</span><span class="n">sample_system</span><span class="p">(</span><span class="n">ncomp</span><span class="o">=</span><span class="n">ncomp</span><span class="p">,</span> <span class="n">ncomp_max</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_comp_number</span><span class="p">)</span>
            <span class="c1">#inner_binary = inner_binary.flatten()</span>

            <span class="c1">#if len(inner_binary) != 0:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sampled_pairs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># While only the inner binary joins the sample, the actual corresponding total system mass is kept track</span>
                <span class="c1"># of. This quantity is important for normalizing the frequency of particular events within a population.</span>
                <span class="c1">#self.sample = np.append(self.sample, inner_binary, axis=0)</span>
                <span class="c1">#sample_list.append(inner_binary)</span>
                <span class="n">sample_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sampled_pairs</span><span class="p">)</span>

                <span class="c1">#self.sample_mass += system_mass</span>
                <span class="n">progress</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">systemgenerator</span><span class="o">.</span><span class="n">m1array_n</span> <span class="o">/</span> <span class="n">prog_norm</span>
                <span class="n">fail_counter</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fail_counter</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="c1"># Eventually imf_array becomes exhausted between 0.8 and 15 Msun, and the remaining primary mass options</span>
                <span class="c1"># (which are all &gt; 15 Msun) have no valid companion masses above 0.8 Msun (because mass ratio &gt; 0.1).</span>
                <span class="c1"># This can lead the sampler to stall if the mass ratio distribution does not pair very massive stars.</span>
                <span class="k">if</span> <span class="n">fail_counter</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_m1_draws</span><span class="p">:</span>
                    <span class="n">minm1</span> <span class="o">=</span> <span class="n">systemgenerator</span><span class="o">.</span><span class="n">highmass_imf_array</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                    <span class="n">maxm2</span> <span class="o">=</span> <span class="n">systemgenerator</span><span class="o">.</span><span class="n">lowmass_imf_array</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;No valid m_comp after </span><span class="si">{</span><span class="n">fail_counter</span><span class="si">}</span><span class="s1"> iterations, with minimum sampling pool m1 &#39;</span>
                                     <span class="sa">f</span><span class="s1">&#39;as </span><span class="si">{</span><span class="n">minm1</span><span class="si">}</span><span class="s1"> and maximum m_comp as </span><span class="si">{</span><span class="n">maxm2</span><span class="si">}</span><span class="s1">. Ending sampling with &#39;</span>
                                     <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">systemgenerator</span><span class="o">.</span><span class="n">m1array_n</span><span class="si">}</span><span class="s1"> remaining m1 options.&#39;</span><span class="p">)</span>
                    <span class="k">break</span>

            <span class="c1"># This sections updates the user on progress based on exhaustion of m1 options and estimates roughly the</span>
            <span class="c1"># remaining time. progress_update_step controls the frequency of updates.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">print_progress</span><span class="p">:</span>
                <span class="n">iteration_counter</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">progress</span> <span class="o">&gt;</span> <span class="n">prev_progress</span> <span class="o">+</span> <span class="n">progress_update_step</span><span class="p">:</span>
                    <span class="n">elapsed_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span>
                    <span class="n">iteration_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">iteration_timer</span>
                    <span class="n">overall_m1_mean_exh_rate</span> <span class="o">=</span> <span class="p">(</span><span class="n">prog_norm</span> <span class="o">-</span> <span class="n">systemgenerator</span><span class="o">.</span><span class="n">m1array_n</span><span class="p">)</span> <span class="o">/</span> <span class="n">elapsed_time</span>
                    <span class="n">m1_mean_exh_rate</span> <span class="o">=</span> <span class="n">prog_norm</span><span class="o">*</span><span class="n">progress_update_step</span> <span class="o">/</span> <span class="n">iteration_time</span>
                    <span class="n">expected_time</span> <span class="o">=</span> <span class="n">systemgenerator</span><span class="o">.</span><span class="n">m1array_n</span> <span class="o">/</span> <span class="n">overall_m1_mean_exh_rate</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Progress: </span><span class="si">{</span><span class="p">(</span><span class="mi">100</span><span class="o">*</span><span class="n">progress</span><span class="p">)</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="s1">%    </span><span class="si">{</span><span class="n">format_time</span><span class="p">(</span><span class="n">elapsed_time</span><span class="p">)</span><span class="si">}</span><span class="s1">&lt;&#39;</span> \
                                     <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">format_time</span><span class="p">(</span><span class="n">expected_time</span><span class="p">)</span><span class="si">}</span><span class="s1"> at </span><span class="si">{</span><span class="n">m1_mean_exh_rate</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1"> M1 options / s&#39;</span> \
                                     <span class="sa">f</span><span class="s1">&#39;(</span><span class="si">{</span><span class="n">iteration_counter</span><span class="o">/</span><span class="n">iteration_time</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1"> iterations/s).&#39;</span><span class="p">)</span>
                    <span class="n">prev_progress</span> <span class="o">=</span> <span class="n">progress</span>
                    <span class="n">iteration_counter</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">iteration_timer</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sample</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">sample_list</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="k">del</span><span class="p">(</span><span class="n">sample_list</span><span class="p">)</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>  <span class="c1"># make sure memory is freed</span>
        <span class="n">total_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Sampling loop completed in </span><span class="si">{</span><span class="n">total_time</span><span class="si">:</span><span class="s1">.6f</span><span class="si">}</span><span class="s1"> s.&#39;</span><span class="p">)</span>
        <span class="n">systemgenerator</span><span class="o">.</span><span class="n">close_pairs_table</span><span class="p">()</span>
        <span class="n">time1</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">time0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Sampling completed in </span><span class="si">{</span><span class="n">time1</span><span class="si">:</span><span class="s1">.6f</span><span class="si">}</span><span class="s1"> s with </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample</span><span class="p">)</span><span class="si">}</span><span class="s1"> binaries.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample</span> <span class="c1">#, self.sample_mass</span></div>


<div class="viewcode-block" id="SimpleBinaryPopulation.save_sample">
<a class="viewcode-back" href="../../bossa.html#bossa.sampling.SimpleBinaryPopulation.save_sample">[docs]</a>
    <span class="k">def</span> <span class="nf">save_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;No sample to save.&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Saving sample...&#39;</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sample</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_columns</span><span class="p">)</span>
        <span class="n">df</span><span class="o">.</span><span class="n">to_parquet</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">save_path</span><span class="p">,</span> <span class="n">engine</span><span class="o">=</span><span class="s1">&#39;pyarrow&#39;</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="s1">&#39;snappy&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Sample saved to </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">save_path</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="CompositeBinaryPopulation">
<a class="viewcode-back" href="../../bossa.html#bossa.sampling.CompositeBinaryPopulation">[docs]</a>
<span class="k">class</span> <span class="nc">CompositeBinaryPopulation</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sample binary populations for a grid of galaxies.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">galaxy_grid_path</span><span class="p">,</span> <span class="n">mmin</span><span class="p">,</span> <span class="n">mmax</span><span class="p">,</span> <span class="n">max_comp_number</span><span class="p">,</span> <span class="n">mass_poolsize</span><span class="p">,</span> <span class="n">qe_max_tries</span><span class="p">,</span> <span class="n">only_binaries</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">invariant_imf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">correlated_orbital_parameters</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parent_logger</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">n_parallel_processes</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mf">0.9</span> <span class="o">*</span> <span class="n">PHYSICAL_CORE_COUNT</span><span class="p">),</span> <span class="n">memory_limit</span><span class="o">=</span><span class="mf">0.8</span><span class="o">*</span><span class="n">TOTAL_PHYSICAL_MEMORY</span><span class="p">,</span>
                 <span class="n">save_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">galaxy_grid_path</span> <span class="o">=</span> <span class="n">galaxy_grid_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mmin</span> <span class="o">=</span> <span class="n">mmin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mmax</span> <span class="o">=</span> <span class="n">mmax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_comp_number</span> <span class="o">=</span> <span class="n">max_comp_number</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">only_binaries</span> <span class="o">=</span> <span class="n">only_binaries</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invariant_imf</span> <span class="o">=</span> <span class="n">invariant_imf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">correlated_orbital_parameters</span> <span class="o">=</span> <span class="n">correlated_orbital_parameters</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mass_poolsize</span> <span class="o">=</span> <span class="n">mass_poolsize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qe_max_tries</span> <span class="o">=</span> <span class="n">qe_max_tries</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_parallel_processes</span> <span class="o">=</span> <span class="n">n_parallel_processes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">memory_limit</span> <span class="o">=</span> <span class="n">memory_limit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_logger</span><span class="p">(</span><span class="n">parent_logger</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid_arr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">save_dir</span> <span class="o">=</span> <span class="n">save_dir</span>

    <span class="k">def</span> <span class="nf">_get_logger</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent_logger</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">parent_logger</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">loggername</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">])</span>
            <span class="n">log_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">LOG_PATH</span><span class="p">,</span> <span class="n">loggername</span><span class="p">,</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1">-%m-%Y_%H:%M:%S.log&#39;</span><span class="p">))</span>
            <span class="n">log_path</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">logger</span> <span class="o">=</span> <span class="n">create_logger</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">loggername</span><span class="p">,</span> <span class="n">fpath</span><span class="o">=</span><span class="n">log_path</span><span class="p">,</span> <span class="n">propagate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loggername</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">])</span>
            <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">loggername</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">logger</span>

    <span class="k">def</span> <span class="nf">_get_zams_sampler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">redshift</span><span class="p">,</span> <span class="n">logsfr</span><span class="p">,</span> <span class="n">feh</span><span class="p">,</span> <span class="n">zoh</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mgal</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">logn_gal</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">galaxy_descr_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">zoh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">zoh_descr</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;1e4ZOH=</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="mf">1e4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">zoh</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">galaxy_descr_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">zoh_descr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mgal</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mgal_descr</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;1e2Mgal=</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="mf">1e2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">mgal</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">galaxy_descr_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mgal_descr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">logn_gal</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logn_gal_descr</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;1e2logn=</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="mf">1e2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">logn_gal</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="n">galaxy_descr_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">logn_gal_descr</span><span class="p">)</span>
        <span class="n">galaxy_descr</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">galaxy_descr_list</span><span class="p">)</span>

        <span class="n">zams_sampler</span> <span class="o">=</span> <span class="n">SimpleBinaryPopulation</span><span class="p">(</span><span class="n">redshift</span><span class="o">=</span><span class="n">redshift</span><span class="p">,</span>
                                              <span class="n">sfr</span><span class="o">=</span><span class="mi">10</span> <span class="o">**</span> <span class="n">logsfr</span><span class="p">,</span>
                                              <span class="n">feh</span><span class="o">=</span><span class="n">feh</span><span class="p">,</span>
                                              <span class="n">m_min</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mmin</span><span class="p">,</span>
                                              <span class="n">m_max</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mmax</span><span class="p">,</span>
                                              <span class="n">max_comp_number</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_comp_number</span><span class="p">,</span>
                                              <span class="n">only_binaries</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">only_binaries</span><span class="p">,</span>
                                              <span class="n">invariant_imf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">invariant_imf</span><span class="p">,</span>
                                              <span class="n">correlated_orbital_parameters</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">correlated_orbital_parameters</span><span class="p">,</span>
                                              <span class="n">poolsize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mass_poolsize</span><span class="p">,</span>
                                              <span class="n">qe_max_tries</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qe_max_tries</span><span class="p">,</span>
                                              <span class="n">galaxy_descriptor</span><span class="o">=</span><span class="n">galaxy_descr</span><span class="p">,</span>
                                              <span class="n">parent_logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">,</span>
                                              <span class="n">save_dir</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">save_dir</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">zams_sampler</span>

<div class="viewcode-block" id="CompositeBinaryPopulation.load_grid">
<a class="viewcode-back" href="../../bossa.html#bossa.sampling.CompositeBinaryPopulation.load_grid">[docs]</a>
    <span class="k">def</span> <span class="nf">load_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">grid_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_pickle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">galaxy_grid_path</span><span class="p">)</span>
        <span class="n">grid_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">grid_df</span><span class="p">),</span> <span class="mi">6</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">grid_arr</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">grid_df</span><span class="p">[</span><span class="s1">&#39;Redshift&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">grid_arr</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">grid_df</span><span class="p">[</span><span class="s1">&#39;Log(SFR [Msun yr-1])&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">grid_arr</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">grid_df</span><span class="p">[</span><span class="s1">&#39;[Fe/H]&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">grid_arr</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">grid_df</span><span class="p">[</span><span class="s1">&#39;12+log(O/H)&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">grid_arr</span><span class="p">[:,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">grid_df</span><span class="p">[</span><span class="s1">&#39;Log(Mgal/Msun)&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="n">grid_arr</span><span class="p">[:,</span> <span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="n">grid_df</span><span class="p">[</span><span class="s1">&#39;Log(Number density [Mpc-3 Msun-1])&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">grid_arr</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Loaded grid </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">galaxy_grid_path</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_get_sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sampler_tuple</span><span class="p">):</span>
        <span class="n">sampler_id</span><span class="p">,</span> <span class="n">sampler_param_arr</span> <span class="o">=</span> <span class="n">sampler_tuple</span>
        <span class="c1"># Sampler_id is an int denoting the line number of the sample in the original galaxygrid file. While at present</span>
        <span class="c1"># it is not used for anything, it could be employed as way to keep track of which galaxy is being sampled.</span>
        <span class="n">zams_sampler</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_zams_sampler</span><span class="p">(</span><span class="o">*</span><span class="n">sampler_param_arr</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Got sampler </span><span class="si">{</span><span class="n">sampler_id</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">zams_sampler</span><span class="o">.</span><span class="n">save_path</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;File </span><span class="si">{</span><span class="n">zams_sampler</span><span class="o">.</span><span class="n">save_path</span><span class="si">}</span><span class="s1"> exists. Skipping...&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">zams_sampler</span><span class="o">.</span><span class="n">set_sampling_pool</span><span class="p">()</span>
            <span class="n">zams_sampler</span><span class="o">.</span><span class="n">get_sample</span><span class="p">()</span>
            <span class="n">zams_sampler</span><span class="o">.</span><span class="n">save_sample</span><span class="p">()</span>

<div class="viewcode-block" id="CompositeBinaryPopulation.sample_grid">
<a class="viewcode-back" href="../../bossa.html#bossa.sampling.CompositeBinaryPopulation.sample_grid">[docs]</a>
    <span class="k">def</span> <span class="nf">sample_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Calling ProcessPoolExecutor with </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_parallel_processes</span><span class="si">}</span><span class="s1"> workers.&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">ProcessPoolExecutor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_parallel_processes</span><span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
            <span class="n">futures</span> <span class="o">=</span> <span class="n">executor</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_sample</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">futures</span><span class="p">:</span>
                <span class="k">pass</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Lucas de S.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>