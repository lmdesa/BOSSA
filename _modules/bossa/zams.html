

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>bossa.zams &mdash; BOSSA 1.0.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=8d563738"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            BOSSA
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../bossa.html">bossa package</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">BOSSA</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">bossa.zams</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for bossa.zams</h1><div class="highlight"><pre>
<span></span><span class="c1"># TODO: Add module documentation</span>
<span class="c1"># TODO: Complete documentation</span>

<span class="sd">&quot;&quot;&quot;Orbital parameter distributions for zero-age main sequence multiple systems.&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">os</span> <span class="kn">import</span> <span class="n">PathLike</span>
<span class="kn">from</span> <span class="nn">time</span> <span class="kn">import</span> <span class="n">time</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Annotated</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
 <span class="c1"># for now tables is imported twice; tables is used for typing, tb for</span>
 <span class="c1"># everything else</span>
<span class="kn">import</span> <span class="nn">tables</span> 
<span class="kn">import</span> <span class="nn">tables</span> <span class="k">as</span> <span class="nn">tb</span>
<span class="kn">import</span> <span class="nn">scipy</span>
<span class="kn">from</span> <span class="nn">numpy._typing</span> <span class="kn">import</span> <span class="n">NDArray</span>
<span class="kn">from</span> <span class="nn">scipy.integrate</span> <span class="kn">import</span> <span class="n">quad</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">interp1d</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">poisson</span><span class="p">,</span> <span class="n">uniform</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">fmin</span>

<span class="c1">#import sys</span>
<span class="c1">#sys.path.append(&#39;..&#39;)</span>
<span class="kn">from</span> <span class="nn">bossa.utils</span> <span class="kn">import</span> <span class="n">create_logger</span><span class="p">,</span> <span class="n">valley_minimum</span><span class="p">,</span> <span class="n">Length</span>
<span class="kn">from</span> <span class="nn">bossa.constants</span> <span class="kn">import</span> <span class="n">LOG_PATH</span><span class="p">,</span> <span class="n">BINARIES_UNCORRELATED_TABLE_PATH</span>


<div class="viewcode-block" id="gen_seed">
<a class="viewcode-back" href="../../bossa.html#bossa.zams.gen_seed">[docs]</a>
<span class="k">def</span> <span class="nf">gen_seed</span><span class="p">(</span><span class="n">logp</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate an unique system identifier from its logp, q and e parameters.&quot;&quot;&quot;</span>
    <span class="n">binary_seed</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span>
        <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trunc</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">logp</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="mf">1e6</span><span class="p">)))),</span>
        <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trunc</span><span class="p">((</span><span class="n">q</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="mf">1e-6</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="mf">1e6</span><span class="p">)))),</span>
        <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">trunc</span><span class="p">(</span><span class="n">e</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="mf">1e3</span><span class="p">))))</span>
    <span class="p">])</span>
    <span class="k">return</span> <span class="n">binary_seed</span></div>



<div class="viewcode-block" id="EccentricityDistribution">
<a class="viewcode-back" href="../../bossa.html#bossa.zams.EccentricityDistribution">[docs]</a>
<span class="k">class</span> <span class="nc">EccentricityDistribution</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Eccentricity probability distribution for a ZAMS star pair.</span>

<span class="sd">    For a given primary of mass ``m1`` and a companion orbit of</span>
<span class="sd">    log10(period) ``logp``, compute the eccentricity probability density</span>
<span class="sd">    function (PDF) for that orbit. All orbits with ``logp &lt;= 0.5``</span>
<span class="sd">    (default) are assumed to be circularized. Orbits with ``logp &gt; 8.0``</span>
<span class="sd">    are not allowed (``p=0``). Primaries with ``m1 &lt; 0.8`` or</span>
<span class="sd">    ``m1 &gt; 150.0`` are not allowed (p=0).</span>

<span class="sd">    Allows for either a mass- and orbital-period dependent power-law</span>
<span class="sd">    distribution, or to set all orbits to be circular.</span>

<span class="sd">    All orbital periods are in days and masses in solar masses.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    canonical : bool, default : False</span>
<span class="sd">        Whether to assume a correlated distribution or not.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    eta : float</span>
<span class="sd">        Index of the eccentricity PDF power law.</span>
<span class="sd">    k : float</span>
<span class="sd">        Normalization constant of the eccentricity PDF power law.</span>
<span class="sd">    e_max : float</span>
<span class="sd">        Maximum eccentricity set by the &lt;70% Roche lobe filling factor</span>
<span class="sd">        at periastron.</span>
<span class="sd">    m1 : float</span>
<span class="sd">        Mass of the primary.</span>
<span class="sd">    logp : float</span>
<span class="sd">        Log10(period) of the given orbit.</span>
<span class="sd">    logp_circ : float</span>
<span class="sd">        Log10(period) below which all orbits are assumed to be</span>
<span class="sd">        circularized. Should always be greater than attr:`logp_min`.</span>
<span class="sd">    logp_min : float</span>
<span class="sd">        Minimum allowed log10(period).</span>
<span class="sd">    logp_max : float</span>
<span class="sd">        Maximum allowed log10(period).</span>
<span class="sd">    m1_min : float</span>
<span class="sd">        Minimum allowed ``m1``.</span>
<span class="sd">    m1_max : float</span>
<span class="sd">        Maximum allowed ``m1``.</span>

<span class="sd">    Warns</span>
<span class="sd">    -----</span>
<span class="sd">    UserWarning</span>
<span class="sd">        If :meth:`prob` is run before :meth:`set_parameters`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The correlated distribution is by Moe &amp; Di Stefano (2017) [1]_</span>
<span class="sd">    with small adjustments as described by de Sá et al. (submitted)</span>
<span class="sd">    [2]_. It takes the shape of a simple power law, with the index eta</span>
<span class="sd">    being dependent on logp; the functional form of this dependency</span>
<span class="sd">    itself depends on m1. A maximum eccentricity is set as a function of</span>
<span class="sd">    logp from the condition that the Roche lobe filling fraction be</span>
<span class="sd">    &lt;70% at periastron.</span>

<span class="sd">    The minimum, maximum and circularization periods are set as in the</span>
<span class="sd">    original work, with log values 0.2, 8.0 and 0.5, respectively.</span>
<span class="sd">    The minimum m1 is set to 0.8 Msun also in accordance with the</span>
<span class="sd">    original work, but the mass range is extended up to 150.0 Msun.</span>

<span class="sd">    The uncorrelated option always returns zero eccentricity.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Moe, M., Di Stefano, R. (2017). Mind Your Ps and Qs: The</span>
<span class="sd">        Interrelation between Period (P) and Mass-ratio (Q)</span>
<span class="sd">        Distributions of Binary Stars. ApJS, 230(2), 55.</span>
<span class="sd">        doi:10.3847/1538-4365/aa6fb6</span>
<span class="sd">    .. [2] de Sá, L. M., Bernardo, A., Rocha, L. S., Bachega, R. R. A.,</span>
<span class="sd">       Horvath, J. E. (submitted).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">canonical</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eta</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">e_max</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m1</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logp</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logp_circ</span> <span class="o">=</span> <span class="mf">0.5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logp_min</span> <span class="o">=</span> <span class="mf">0.2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logp_max</span> <span class="o">=</span> <span class="mf">8.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m1_min</span> <span class="o">=</span> <span class="mf">0.8</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m1_max</span> <span class="o">=</span> <span class="mi">150</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">canonical</span> <span class="o">=</span> <span class="n">canonical</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_eta_lowmass</span><span class="p">(</span><span class="n">logp</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the power-law index for ``logp``and ``m1 &lt;= 3``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">0.6</span> <span class="o">-</span> <span class="mf">0.7</span> <span class="o">/</span> <span class="p">(</span><span class="n">logp</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_eta_highmass</span><span class="p">(</span><span class="n">logp</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the power-law index for ``logp`` and ``m1 &gt;= 7``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">0.9</span> <span class="o">-</span> <span class="mf">0.2</span> <span class="o">/</span> <span class="p">(</span><span class="n">logp</span><span class="o">-</span><span class="mf">0.5</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_e_max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logp</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the maximum eccentricity :attr:`e_max`.</span>

<span class="sd">        The maximum eccentricity is set by the condition that the Roche</span>
<span class="sd">        lobe filling factor be &lt; 70% at periastron.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">p</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="n">logp</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">e_max</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">p</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_eta_midmass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logp</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">m1</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the power-law index for the ``logp`` and ``3&lt;m1&lt;7``.</span>

<span class="sd">        The index is given by a linear interpolation between the eta</span>
<span class="sd">        functions for late- (&lt;= 3 Msun), :meth:`_eta_lowmass`; and</span>
<span class="sd">        early-type (&gt;= 7 Msun), :meth:`_eta_highmass` primaries.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">eta_highmass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eta_highmass</span><span class="p">(</span><span class="n">logp</span><span class="p">)</span>
        <span class="n">eta_lowmass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eta_lowmass</span><span class="p">(</span><span class="n">logp</span><span class="p">)</span>
        <span class="n">eta_midmass</span> <span class="o">=</span> <span class="p">(</span><span class="n">m1</span><span class="o">-</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">eta_highmass</span><span class="o">-</span><span class="n">eta_lowmass</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">eta_lowmass</span>
        <span class="k">return</span> <span class="n">eta_midmass</span>

<div class="viewcode-block" id="EccentricityDistribution.set_parameters">
<a class="viewcode-back" href="../../bossa.html#bossa.zams.EccentricityDistribution.set_parameters">[docs]</a>
    <span class="k">def</span> <span class="nf">set_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">logp</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set power-law parameters at ``m1``, ``logp``.</span>

<span class="sd">        Sets :attr:`eta`, :attr:`k` and :attr:`e_max` at ``m1`` and</span>
<span class="sd">        :attr:``logp``. If the distribution is set to uncorrelated, or</span>
<span class="sd">        if ``m1`` and/or ``logp`` are out of bounds, all parameters are</span>
<span class="sd">        set to zero.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">m1</span> <span class="o">=</span> <span class="n">m1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logp</span> <span class="o">=</span> <span class="n">logp</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">canonical</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eta</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">logp</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">logp_circ</span> <span class="ow">or</span> <span class="n">logp</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">logp_max</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eta</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">m1</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">m1_min</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">eta</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">m1</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">eta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eta_lowmass</span><span class="p">(</span><span class="n">logp</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">m1</span> <span class="o">&lt;</span> <span class="mi">7</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">eta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eta_midmass</span><span class="p">(</span><span class="n">logp</span><span class="p">,</span> <span class="n">m1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">m1</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m1_max</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">eta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eta_highmass</span><span class="p">(</span><span class="n">logp</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">eta</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_e_max</span><span class="p">(</span><span class="n">logp</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">e_max</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.1</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="mi">0</span></div>


    <span class="k">def</span> <span class="nf">_force_circular_orbit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Eccentricity distribution forcing circular orbits.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">e</span> <span class="o">&lt;=</span> <span class="mf">1e-4</span><span class="p">:</span>
            <span class="n">prob</span> <span class="o">=</span> <span class="mf">1e4</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prob</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">prob</span>

<div class="viewcode-block" id="EccentricityDistribution.prob">
<a class="viewcode-back" href="../../bossa.html#bossa.zams.EccentricityDistribution.prob">[docs]</a>
    <span class="k">def</span> <span class="nf">prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the eccentricity PDF value at the given e.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        e : float</span>
<span class="sd">            Eccentricity at which to compute the PDF.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        prob : float</span>
<span class="sd">            PDF value at e.</span>

<span class="sd">        Warns</span>
<span class="sd">        -----</span>
<span class="sd">        UserWarning</span>
<span class="sd">            If power law parameters are not set up</span>
<span class="sd">            (:meth:`set_parameters` has not been called yet).</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        If ``logp &lt;=``:attr:`logp_circ` (default 0.5), the method forces</span>
<span class="sd">        `e=0` by approximating a delta at `e=0` with a finite step. This</span>
<span class="sd">        is done to avoid dividing by zero while still allowing the PDF</span>
<span class="sd">        to integrate to 1. An artificial plateau is also inserted at</span>
<span class="sd">        ``e &lt;= 0.0001`` to avoid the probability exploding for circular</span>
<span class="sd">        systems, at the cost of slightly shifting the PDF&#39;s norm from 1.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Function parameters not set up. Please run &#39;</span>
                          <span class="s1">&#39;set_parameters(m1, logp) first.&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">canonical</span><span class="p">:</span>
            <span class="n">prob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_force_circular_orbit</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">logp_circ</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">logp</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">logp_min</span><span class="p">:</span>
            <span class="n">prob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_force_circular_orbit</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">e</span> <span class="o">&lt;=</span> <span class="mf">0.0001</span><span class="p">:</span>  <span class="c1"># avoid divide by zero</span>
            <span class="n">prob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">*</span> <span class="mf">0.0001</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span>
        <span class="k">elif</span> <span class="n">e</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">e_max</span><span class="p">:</span>
            <span class="n">prob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">*</span> <span class="n">e</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prob</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">prob</span></div>
</div>



<div class="viewcode-block" id="MassRatioDistribution">
<a class="viewcode-back" href="../../bossa.html#bossa.zams.MassRatioDistribution">[docs]</a>
<span class="k">class</span> <span class="nc">MassRatioDistribution</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mass ratio probability distribution for a ZAMS star pair.</span>

<span class="sd">    For a given primary of mass ``m1`` and a companion orbit of</span>
<span class="sd">    log10(period) ``logp``, compute the mass ratio probability density</span>
<span class="sd">    function (PDF) for that orbit. The companion mass being ``m_cp``,</span>
<span class="sd">    the mass ratio is defined as ``q=m_cp/m1``, and is limited to the</span>
<span class="sd">    interval ``0.1 &lt;= q &lt;= 1.0``.</span>

<span class="sd">    Allows for either a mass- and orbital-dependent broken power-law</span>
<span class="sd">    with a &quot;twin&quot; (``q &gt; 0.95``) excess; or an uncorrelated uniform</span>
<span class="sd">    distribution.</span>

<span class="sd">    All orbital periods are in days and masses in solar masses.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    canonical : bool, default : False</span>
<span class="sd">        Whether to assume a correlated distribution or not.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    solar_llim : float</span>
<span class="sd">        Lower mass limit of &quot;solar-type&quot; primaries.</span>
<span class="sd">    solar_ulim : float</span>
<span class="sd">        Upper mass limit of &quot;solar-type&quot; primaries.</span>
<span class="sd">    a_point : float</span>
<span class="sd">        Mass midpoint for A-/late B-type primaries.</span>
<span class="sd">    ob_llim : float</span>
<span class="sd">        Lower mass limit of mid B-, early B- and O-type primaries.</span>
<span class="sd">    gamma_largeq : float</span>
<span class="sd">        Power law PDF index for ``0.3 &lt;= q &lt;= 1.0``.</span>
<span class="sd">    gamma_smallq : float</span>
<span class="sd">        Power law PDF index for ``0.1 &lt;= q &lt; 0.3``.</span>
<span class="sd">    f_twin : float</span>
<span class="sd">        Excess fraction of ``q&gt;0.95`` pairs relative to a power-law.</span>
<span class="sd">    k : float</span>
<span class="sd">        Power law PDF normalization constant.</span>
<span class="sd">    logp_min : float</span>
<span class="sd">        Minimum allowed log10(period).</span>
<span class="sd">    logp_max : float</span>
<span class="sd">        Maximum allowed log10(period).</span>
<span class="sd">    m1_min : float</span>
<span class="sd">        Minimum allowed ``m1``.</span>
<span class="sd">    m1_max : float</span>
<span class="sd">        Maximum allowed ``m1``.</span>


<span class="sd">    Warns</span>
<span class="sd">    -----</span>
<span class="sd">    UserWarning</span>
<span class="sd">        If :meth:`prob` is run before :meth:`set_parameters`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The correlated distribution is by Moe &amp; Di Stefano (2017) [1]_ with</span>
<span class="sd">    small adjustments as described by de Sá et al. (submitted) [2]_. It</span>
<span class="sd">    takes the shape of a two-part power law, with index</span>
<span class="sd">    :attr:`gamma_smallq` for ``0.1 &lt;= q &lt; 0.3`` and :attr:`gamma_largeq`</span>
<span class="sd">    for ``0.3 &lt;= q &lt;= 1.0``. It also includes an excess of systems with</span>
<span class="sd">    ``q &gt; 0.95`` (twin pairs) expressed as the twin fraction</span>
<span class="sd">    :attr:`f_twin`, so that at `q &gt; 0.95` the PDF is</span>
<span class="sd">    `(1+f_twin) * power_law`. As this excess is only observed for</span>
<span class="sd">    shorter-period systems, there is a maximum ``logp`` for which the</span>
<span class="sd">    excess twin population is present.</span>

<span class="sd">    Solar-type primaries are defined as having masses</span>
<span class="sd">    ``0.8 &lt; m1 &lt; 1.2``. The midpoint of A-/late B-type primaries is</span>
<span class="sd">    defined to be at ``m1 = 3.5``. Mid B-, early B- and O-type primaries</span>
<span class="sd">    are defined as having mass ``m1 &gt; 6.0``. The PDF is defined piecewise</span>
<span class="sd">    for each the two ranges and the midpoint. Interpolation gives the</span>
<span class="sd">    PDF in the two intermediary ranges: solar-A (``1.2 &lt;= m1 &lt; 3.5``)</span>
<span class="sd">    and A-OB (``3.5 &lt; m1 &lt;= 6``).</span>

<span class="sd">    The minimum and maximum periods are set as in the original work,</span>
<span class="sd">    with log10 values `0.2` and `8.0`, respectively. The minimum ``m1``</span>
<span class="sd">    is set to `0.8` also in accordance with the original work, but the</span>
<span class="sd">    mass range is extended up to `150.0`. The minimum ``q`` is set to</span>
<span class="sd">    `0.1` as in the original work.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">canonical</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solar_llim</span> <span class="o">=</span> <span class="mf">0.8</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solar_ulim</span> <span class="o">=</span> <span class="mf">1.2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a_point</span> <span class="o">=</span> <span class="mf">3.5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ob_llim</span> <span class="o">=</span> <span class="mf">6.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_min</span> <span class="o">=</span> <span class="mf">0.1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_mid</span> <span class="o">=</span> <span class="mf">0.3</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_twin</span> <span class="o">=</span> <span class="mf">0.95</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_max</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma_largeq</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma_smallq</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f_twin</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logp_min</span> <span class="o">=</span> <span class="mf">0.2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logp_max</span> <span class="o">=</span> <span class="mf">8.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m1_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solar_llim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m1_max</span> <span class="o">=</span> <span class="mf">150.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">canonical</span> <span class="o">=</span> <span class="n">canonical</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_canonical_prob_distribution</span> <span class="o">=</span> <span class="n">uniform</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_logp_twin</span><span class="p">(</span><span class="n">m1</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return maximum ``logp`` of the twin excess for ``m1``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">m1</span> <span class="o">&lt;=</span> <span class="mf">6.5</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">8.0</span> <span class="o">-</span> <span class="n">m1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">1.5</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_f_twin_logp_small</span><span class="p">(</span><span class="n">m1</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return twin fraction at ``logp &lt; 1``, for ``m1``.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">0.3</span> <span class="o">-</span> <span class="mf">0.15</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">m1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_f_twin_logp_large</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">logp</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return twin fraction at ``logp &gt;= 1``, for ``m1``.&quot;&quot;&quot;</span>
        <span class="n">logp_twin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_logp_twin</span><span class="p">(</span><span class="n">m1</span><span class="p">)</span>
        <span class="n">f_twin_logp_small</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_f_twin_logp_small</span><span class="p">(</span><span class="n">m1</span><span class="p">)</span>
        <span class="n">f_twin_logp_large</span> <span class="o">=</span> <span class="p">(</span><span class="n">f_twin_logp_small</span>
                             <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">logp</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">logp_twin</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">f_twin_logp_large</span>

    <span class="c1"># TODO: make f_twin 0 if m1 or logp is out of bounds</span>
    <span class="k">def</span> <span class="nf">_get_f_twin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">logp</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return twin fraction at ``m1``, ``logp``.&quot;&quot;&quot;</span>
        <span class="n">logp_twin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_logp_twin</span><span class="p">(</span><span class="n">m1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">logp</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">:</span>
            <span class="n">ftwin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_f_twin_logp_small</span><span class="p">(</span><span class="n">m1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">logp</span> <span class="o">&lt;</span> <span class="n">logp_twin</span><span class="p">:</span>
            <span class="n">ftwin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_f_twin_logp_large</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">logp</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ftwin</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">return</span> <span class="n">ftwin</span>

    <span class="k">def</span> <span class="nf">_get_gamma_largeq_solar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logp</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return solar-type :attr:`gamma_largeq` at ``logp``.</span>

<span class="sd">        Returns the power-law index at ``0.3 &lt;= q &lt;= 1.0`` for</span>
<span class="sd">        solar-type primaries at ``logp``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">logp</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">logp_min</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">elif</span> <span class="n">logp</span> <span class="o">&lt;</span> <span class="mf">5.0</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span>
        <span class="k">elif</span> <span class="n">logp</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">logp_max</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">-</span> <span class="mf">0.3</span> <span class="o">*</span> <span class="p">(</span><span class="n">logp</span> <span class="o">-</span> <span class="mf">5.0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">return</span> <span class="n">g</span>

    <span class="k">def</span> <span class="nf">_get_gamma_largeq_a</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logp</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return A/B :attr:`gamma_largeq` at ``logp``.</span>

<span class="sd">        Returns the power-law index at ``0.3 &lt;= q &lt;= 1.0`` for midpoint</span>
<span class="sd">        A/early B-type primaries at ``logp``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">logp</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">logp_min</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">elif</span> <span class="n">logp</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span>
        <span class="k">elif</span> <span class="n">logp</span> <span class="o">&lt;</span> <span class="mf">4.5</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">-</span> <span class="mf">0.2</span> <span class="o">*</span> <span class="p">(</span><span class="n">logp</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">logp</span> <span class="o">&lt;</span> <span class="mf">6.5</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.2</span> <span class="o">-</span> <span class="mf">0.4</span> <span class="o">*</span> <span class="p">(</span><span class="n">logp</span> <span class="o">-</span> <span class="mf">4.5</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">logp</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">logp_max</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">return</span> <span class="n">g</span>

    <span class="k">def</span> <span class="nf">_get_gamma_largeq_ob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logp</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return B/O :attr:`gamma_largeq` at ``logp``.</span>

<span class="sd">        Returns the power-law index at ``0.3 &lt;= q &lt;= 1.0`` for mid B,</span>
<span class="sd">        late B and O-type primaries at ``logp``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">logp</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">logp_min</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">elif</span> <span class="n">logp</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span>
        <span class="k">elif</span> <span class="n">logp</span> <span class="o">&lt;</span> <span class="mf">2.0</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.5</span> <span class="o">-</span> <span class="mf">0.9</span> <span class="o">*</span> <span class="p">(</span><span class="n">logp</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">logp</span> <span class="o">&lt;</span> <span class="mf">4.0</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.4</span> <span class="o">-</span> <span class="mf">0.3</span> <span class="o">*</span> <span class="p">(</span><span class="n">logp</span> <span class="o">-</span> <span class="mf">2.0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">logp</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">logp_max</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">return</span> <span class="n">g</span>

    <span class="k">def</span> <span class="nf">_get_gamma_smallq_solar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logp</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return solar-type :attr:`gamma_smallq` at ``logp``.</span>

<span class="sd">        Returns the power-law index at ``0.1 &lt;= q &lt; 0.3`` for solar-type</span>
<span class="sd">        primaries at ``logp``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">logp</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">logp_min</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">elif</span> <span class="n">logp</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">logp_max</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="mf">0.3</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">return</span> <span class="n">g</span>

    <span class="k">def</span> <span class="nf">_get_gamma_smallq_a</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logp</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return A/B :attr:`gamma_smallq` at ``logp``.</span>

<span class="sd">        Returns the power-law index at ``0.1 &lt;= q &lt; 0.3`` for midpoint</span>
<span class="sd">        A/early B-type primaries at ``logp``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">logp</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">logp_min</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">elif</span> <span class="n">logp</span> <span class="o">&lt;</span> <span class="mf">2.5</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="mf">0.2</span>
        <span class="k">elif</span> <span class="n">logp</span> <span class="o">&lt;</span> <span class="mf">5.5</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="mf">0.2</span> <span class="o">-</span> <span class="mf">0.3</span> <span class="o">*</span> <span class="p">(</span><span class="n">logp</span> <span class="o">-</span> <span class="mf">2.5</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">logp</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">logp_max</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.7</span> <span class="o">-</span> <span class="mf">0.2</span> <span class="o">*</span> <span class="p">(</span><span class="n">logp</span> <span class="o">-</span> <span class="mf">5.5</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">return</span> <span class="n">g</span>

    <span class="k">def</span> <span class="nf">_get_gamma_smallq_ob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logp</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return B/O :attr:`gamma_smallq` at ``logp``.</span>

<span class="sd">        Returns the power-law index at ``0.1 &lt;= q &lt; 0.3`` for mid B-,</span>
<span class="sd">        late B- and O-type primaries at ``logp``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">logp</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">logp_min</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">logp</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="mf">0.1</span>
        <span class="k">elif</span> <span class="n">logp</span> <span class="o">&lt;</span> <span class="mf">3.0</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="o">-</span> <span class="mf">0.15</span> <span class="o">*</span> <span class="p">(</span><span class="n">logp</span> <span class="o">-</span> <span class="mf">1.1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">logp</span> <span class="o">&lt;</span> <span class="mf">5.6</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.2</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">logp</span> <span class="o">-</span> <span class="mf">3.0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">logp</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">logp_max</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.5</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">g</span>

    <span class="k">def</span> <span class="nf">_get_gamma_largeq_solar_a</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">logp</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return solar-A/B :attr:`gamma_largeq` at ``m1``, ``logp``.</span>

<span class="sd">        Compute the power-law index at 0.3 &lt;= q &lt;= 1.0 for primaries of</span>
<span class="sd">        mass ``m1`` between solar and midpoint A/early B-type. This is</span>
<span class="sd">        done by interpolating, at the given ``logp``, between the</span>
<span class="sd">        indices from :meth:`_get_gamma_largeq_solar` and</span>
<span class="sd">        :meth:`_get_gamma_largeq_a`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">lowmass_g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_gamma_largeq_solar</span><span class="p">(</span><span class="n">logp</span><span class="p">)</span>
        <span class="n">highmass_g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_gamma_largeq_a</span><span class="p">(</span><span class="n">logp</span><span class="p">)</span>
        <span class="n">slope</span> <span class="o">=</span> <span class="p">(</span><span class="n">highmass_g</span> <span class="o">-</span> <span class="n">lowmass_g</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a_point</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">solar_ulim</span><span class="p">)</span>
        <span class="n">midmass_g</span> <span class="o">=</span> <span class="p">(</span><span class="n">m1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">solar_ulim</span><span class="p">)</span> <span class="o">*</span> <span class="n">slope</span> <span class="o">+</span> <span class="n">lowmass_g</span>
        <span class="k">return</span> <span class="n">midmass_g</span>

    <span class="k">def</span> <span class="nf">_get_gamma_largeq_a_ob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">logp</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return A/B-B/O :attr:`gamma_largeq` at ``m1``, ``logp``.</span>

<span class="sd">        Compute the power-law index at 0.3 &lt;= q &lt;= 1.0 for primaries of</span>
<span class="sd">        mass ``m1`` between midpoint A/early B-type and mid B-, late B-</span>
<span class="sd">        and O-type primaries. This is done by interpolating, at the</span>
<span class="sd">        given ``logp``, between the indices from</span>
<span class="sd">        :meth:`_get_gamma_largeq_a` and :meth:`_get_gamma_largeq_ob`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">lowmass_g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_gamma_largeq_a</span><span class="p">(</span><span class="n">logp</span><span class="p">)</span>
        <span class="n">highmass_g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_gamma_largeq_ob</span><span class="p">(</span><span class="n">logp</span><span class="p">)</span>
        <span class="n">slope</span> <span class="o">=</span> <span class="p">(</span><span class="n">highmass_g</span> <span class="o">-</span> <span class="n">lowmass_g</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ob_llim</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_point</span><span class="p">)</span>
        <span class="n">midmass_g</span> <span class="o">=</span> <span class="p">(</span><span class="n">m1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_point</span><span class="p">)</span> <span class="o">*</span> <span class="n">slope</span> <span class="o">+</span> <span class="n">lowmass_g</span>
        <span class="k">return</span> <span class="n">midmass_g</span>

    <span class="k">def</span> <span class="nf">_get_gamma_smallq_solar_a</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">logp</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return solar-A/B :attr:`gamma_smallq` at ``m1``, ``logp``.</span>

<span class="sd">        Compute the power-law index at 0.1 &lt;= q &lt; 0.3 for primaries of</span>
<span class="sd">        mass ``m1`` between solar and midpoint A/early B-type. This is</span>
<span class="sd">        done by interpolating, at the given ``logp``, between the</span>
<span class="sd">        indices from :meth:`_get_gamma_smallq_solar` and</span>
<span class="sd">        :meth:`_get_gamma_smallq_a`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">lowmass_g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_gamma_smallq_solar</span><span class="p">(</span><span class="n">logp</span><span class="p">)</span>
        <span class="n">highmass_g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_gamma_smallq_a</span><span class="p">(</span><span class="n">logp</span><span class="p">)</span>
        <span class="n">slope</span> <span class="o">=</span> <span class="p">(</span><span class="n">highmass_g</span> <span class="o">-</span> <span class="n">lowmass_g</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a_point</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">solar_ulim</span><span class="p">)</span>
        <span class="n">midmass_g</span> <span class="o">=</span> <span class="p">(</span><span class="n">m1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">solar_ulim</span><span class="p">)</span> <span class="o">*</span> <span class="n">slope</span> <span class="o">+</span> <span class="n">lowmass_g</span>
        <span class="k">return</span> <span class="n">midmass_g</span>

    <span class="k">def</span> <span class="nf">_get_gamma_smallq_a_ob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">logp</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return A/B-B/O :attr:`gamma_smallq` at ``m1``, ``logp``.</span>

<span class="sd">        Compute the power-law index at 0.1 &lt;= q &lt; 0.3 for primaries of</span>
<span class="sd">        mass ``m1`` between midpoint A/early B-type and mid B-, late B-</span>
<span class="sd">        and O-type primaries. This is done by interpolating, at the</span>
<span class="sd">        given ``logp``, between the indices from</span>
<span class="sd">        :meth:`_get_gamma_smallq_a` and :meth:`_get_gamma_smallq_ob`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">lowmass_g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_gamma_smallq_a</span><span class="p">(</span><span class="n">logp</span><span class="p">)</span>
        <span class="n">highmass_g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_gamma_smallq_ob</span><span class="p">(</span><span class="n">logp</span><span class="p">)</span>
        <span class="n">slope</span> <span class="o">=</span> <span class="p">(</span><span class="n">highmass_g</span> <span class="o">-</span> <span class="n">lowmass_g</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ob_llim</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_point</span><span class="p">)</span>
        <span class="n">midmass_g</span> <span class="o">=</span> <span class="p">(</span><span class="n">m1</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_point</span><span class="p">)</span> <span class="o">*</span> <span class="n">slope</span> <span class="o">+</span> <span class="n">lowmass_g</span>
        <span class="k">return</span> <span class="n">midmass_g</span>

<div class="viewcode-block" id="MassRatioDistribution.set_parameters">
<a class="viewcode-back" href="../../bossa.html#bossa.zams.MassRatioDistribution.set_parameters">[docs]</a>
    <span class="k">def</span> <span class="nf">set_parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">logp</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set distribution power-law parameters at ``m1``, ``logp``.</span>

<span class="sd">        Sets :attr:`gamma_largeq`, :attr:`gamma_smallq`, :attr:`k` and</span>
<span class="sd">        :attr:`f_twin`. If the distribution is set to uncorrelated, or</span>
<span class="sd">        if ``m1`` and/or ``logp`` are out of bounds, all parameters are</span>
<span class="sd">        set to zero.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">canonical</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gamma_largeq</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gamma_smallq</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">elif</span> <span class="n">m1</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">m1_min</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gamma_largeq</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gamma_smallq</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">elif</span> <span class="n">m1</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">solar_ulim</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gamma_largeq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_gamma_largeq_solar</span><span class="p">(</span><span class="n">logp</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gamma_smallq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_gamma_smallq_solar</span><span class="p">(</span><span class="n">logp</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">m1</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_point</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gamma_largeq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_gamma_largeq_solar_a</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">logp</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gamma_smallq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_gamma_smallq_solar_a</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">logp</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">m1</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_point</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gamma_largeq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_gamma_largeq_a</span><span class="p">(</span><span class="n">logp</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gamma_smallq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_gamma_smallq_a</span><span class="p">(</span><span class="n">logp</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">m1</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">ob_llim</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gamma_largeq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_gamma_largeq_a_ob</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">logp</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gamma_smallq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_gamma_smallq_a_ob</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">logp</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">m1</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m1_max</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gamma_largeq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_gamma_largeq_ob</span><span class="p">(</span><span class="n">logp</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gamma_smallq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_gamma_smallq_ob</span><span class="p">(</span><span class="n">logp</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gamma_largeq</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gamma_smallq</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f_twin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_f_twin</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">logp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_k</span><span class="p">()</span></div>


    <span class="k">def</span> <span class="nf">_set_k</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set :attr:`k` so that the PDF integrates to 1.&quot;&quot;&quot;</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">quad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prob</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_min</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_max</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">/=</span> <span class="n">norm</span>

<div class="viewcode-block" id="MassRatioDistribution.prob">
<a class="viewcode-back" href="../../bossa.html#bossa.zams.MassRatioDistribution.prob">[docs]</a>
    <span class="k">def</span> <span class="nf">prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">q</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the mass ratio PDF value at the given e.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        q : float</span>
<span class="sd">            Mass ratio at which to compute the PDF.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        prob : float</span>
<span class="sd">            PDF value at q.</span>

<span class="sd">        Warns</span>
<span class="sd">        -----</span>
<span class="sd">        UserWarning</span>
<span class="sd">            If power law parameters are not set up</span>
<span class="sd">            (:meth:`set_parameters` has not been called yet).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_largeq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Function parameters not set up. &#39;</span>
                          <span class="s1">&#39;Please run set_parameters(m1, logp) first.&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">canonical</span><span class="p">:</span>
            <span class="n">prob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_canonical_prob_distribution</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">q</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_min</span><span class="p">:</span>
            <span class="n">prob</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">elif</span> <span class="n">q</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_mid</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mf">0.3</span> <span class="o">**</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gamma_largeq</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_smallq</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span>
            <span class="n">prob</span> <span class="o">=</span> <span class="n">k</span> <span class="o">*</span> <span class="n">q</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_smallq</span>
        <span class="k">elif</span> <span class="n">q</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_twin</span><span class="p">:</span>
            <span class="n">prob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">*</span> <span class="n">q</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_largeq</span>
        <span class="k">elif</span> <span class="n">q</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_max</span><span class="p">:</span>
            <span class="n">powerlaw</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">*</span> <span class="n">q</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">gamma_largeq</span>
            <span class="n">prob</span> <span class="o">=</span> <span class="n">powerlaw</span> <span class="o">*</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">f_twin</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prob</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">return</span> <span class="n">prob</span></div>
</div>



<div class="viewcode-block" id="CompanionFrequencyDistributionHighQ">
<a class="viewcode-back" href="../../bossa.html#bossa.zams.CompanionFrequencyDistributionHighQ">[docs]</a>
<span class="k">class</span> <span class="nc">CompanionFrequencyDistributionHighQ</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Orbital period distribution for a ``0.3&lt;=q&lt;=1`` ZAMS star pair.</span>

<span class="sd">    For a primary of mass ``m1``, compute the log orbital period</span>
<span class="sd">    (``logp``) probability density function (PDF) for a companion with</span>
<span class="sd">    some mass ``m_cp`` such that ``0.3 &lt;= q &lt;= 1.0`` (``q=m_cp/m1``).</span>

<span class="sd">    The PDF is a strongly ``m1``- and ``logp``-dependent piecewise</span>
<span class="sd">    function of power-law, linear and exponential components.</span>

<span class="sd">    All orbital periods are given in days and masses in solar masses.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m1 : float</span>
<span class="sd">        Primary mass.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    m1 : float</span>
<span class="sd">        Primary mass.</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    CompanionFrequencyDistribution :</span>
<span class="sd">        Inherits from this class and extrapolates the distribution down</span>
<span class="sd">        to ``q=0.1``. Includes an uncorrelated distribution option.</span>
<span class="sd">    MultipleFraction :</span>
<span class="sd">        Accounts for higher-order multiples in the companion frequency.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The distribution is by Moe &amp; Di Stefano (2017) [1]_, with small</span>
<span class="sd">    adjustments as described by de Sá et al. (submitted) [2]_. Although</span>
<span class="sd">    it is referred to as a PDF, the distribution is defined as a</span>
<span class="sd">    companion frequency,</span>

<span class="sd">    .. math::</span>

<span class="sd">        f_{\\log P; q&gt;0.3} (M_1,P) := \\frac{d N_{cp, q&gt;0.3} }{d N_1\\,</span>
<span class="sd">         d\\log P},</span>

<span class="sd">    i.e., the number of companions, per primary with mass :math:`M_1`,</span>
<span class="sd">    per orbital period decade, around a period :math:`P`.</span>

<span class="sd">    The companion frequency is empirically fitted for</span>
<span class="sd">    ``0.2 &lt;= logp &lt; 1``, ``logp = 2.7``, ``logp = 5.5`` and</span>
<span class="sd">    ``5.5 &lt; logp &lt;= 8.0``. For the intermediate intervals, it is set to</span>
<span class="sd">    increase linearly with ``logp``.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">A</span> <span class="o">=</span> <span class="mf">0.018</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;float: Slope within :const:`DELTA_LOGP`/2 of ``logp=2.7``.&quot;&quot;&quot;</span>
    <span class="n">DELTA_LOGP</span> <span class="o">=</span> <span class="mf">0.7</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;float: Half-width of the range where the slope is :const:`A`.&quot;&quot;&quot;</span>
    <span class="n">LOGP_MIN</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;float: Minimum allowed ``logp``.&quot;&quot;&quot;</span>
    <span class="n">LOGP_MAX</span> <span class="o">=</span> <span class="mf">8.0</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;float: Maximum allowed ``logp``.&quot;&quot;&quot;</span>
    <span class="n">M1_MIN</span> <span class="o">=</span> <span class="mf">0.8</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;float: Minimum allowed ``m1``.&quot;&quot;&quot;</span>
    <span class="n">M1_MAX</span> <span class="o">=</span> <span class="mi">150</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;float: Maximum allowed ``m1``.&quot;&quot;&quot;</span>
    <span class="n">LOGP_BREAKS</span> <span class="o">=</span> <span class="p">[</span><span class="n">LOGP_MIN</span><span class="p">,</span>
                   <span class="mf">1.0</span><span class="p">,</span>
                   <span class="mf">2.7</span> <span class="o">-</span> <span class="n">DELTA_LOGP</span><span class="p">,</span>
                   <span class="mf">2.7</span> <span class="o">+</span> <span class="n">DELTA_LOGP</span><span class="p">,</span>
                   <span class="mf">5.5</span><span class="p">,</span>
                   <span class="n">LOGP_MAX</span><span class="p">]</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;list: Distribution `logp` breaks.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m1</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m1</span> <span class="o">=</span> <span class="n">m1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_f_logp1_q03</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_f_logp27_q03</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_f_logp55_q03</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">f_logp1_q03</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;First companion frequency constant.</span>

<span class="sd">        Frequency of companions with ``0.2 &lt;= logp &lt; 1`` and</span>
<span class="sd">        ``0.3 &lt;= q &lt;= 1.0`` for primaries of mass :attr:`m1`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f_logp1_q03</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_f_logp1_q03</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.02</span>
                                 <span class="o">+</span> <span class="mf">0.04</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m1</span><span class="p">)</span>
                                 <span class="o">+</span> <span class="mf">0.07</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f_logp1_q03</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">f_logp27_q03</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Second companion frequency constant.</span>

<span class="sd">        Frequency of companions with ``logp = 2.7`` and</span>
<span class="sd">        ``0.3 &lt;= q &lt;= 1.0`` for primaries of mass :attr:``m1``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f_logp27_q03</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_f_logp27_q03</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.039</span>
                                  <span class="o">+</span> <span class="mf">0.07</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m1</span><span class="p">)</span>
                                  <span class="o">+</span> <span class="mf">0.01</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f_logp27_q03</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">f_logp55_q03</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Third companion frequency constant.</span>

<span class="sd">        Frequency of companions with ``logp = 5.5`` and</span>
<span class="sd">        ``0.3 &lt;= q &lt;= 1.0`` for primaries of mass :attr:`m1`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f_logp55_q03</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_f_logp55_q03</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.078</span>
                                  <span class="o">-</span> <span class="mf">0.05</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m1</span><span class="p">)</span>
                                  <span class="o">+</span> <span class="mf">0.04</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m1</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f_logp55_q03</span>

    <span class="k">def</span> <span class="nf">_f1</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return companion frequency in the first interval.</span>

<span class="sd">        In the ``0.2 &lt;= logp &lt; 1`` interval, the companion frequency is</span>
<span class="sd">        constant and equal to :attr:`f_logp1_q03` in this range.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">f_logp1_q03</span>

    <span class="k">def</span> <span class="nf">_f2</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logp</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return companion frequency in the second interval.</span>

<span class="sd">        In the ``1&lt;=logp&lt;2.7-DELTA_LOGP`` interval, the companion</span>
<span class="sd">        frequency is linear on ``logp``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">logp</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">1.7</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">DELTA_LOGP</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f_logp27_q03</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">f_logp1_q03</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">DELTA_LOGP</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">f_logp1_q03</span> <span class="o">+</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>

    <span class="k">def</span> <span class="nf">_f3</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logp</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return companion frequency in the third interval.</span>

<span class="sd">        In the ``2.7-``:const:`DELTA_LOGP```&lt;=logp&lt;2.7+``</span>
<span class="sd">        :const:`DELTA_LOGP` interval, the companion frequency is</span>
<span class="sd">        linear on ``logp``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">f_logp27_q03</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">*</span> <span class="p">(</span><span class="n">logp</span> <span class="o">-</span> <span class="mf">2.7</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_f4</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logp</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return companion frequency in the fourth interval.</span>

<span class="sd">        In the ``2.7 +``:const:`DELTA_LOGP```&lt;= logp &lt; 5.5`` interval,</span>
<span class="sd">        the companion frequency is linear on `logp`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="n">logp</span> <span class="o">-</span> <span class="mf">2.7</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">DELTA_LOGP</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.8</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">DELTA_LOGP</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f_logp55_q03</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">f_logp27_q03</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">DELTA_LOGP</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">f_logp27_q03</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">DELTA_LOGP</span> <span class="o">+</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span>

    <span class="k">def</span> <span class="nf">_f5</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logp</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Companion frequency in the fifth interval.</span>

<span class="sd">        In the ``5.5 &lt;= logp &lt;= 8.0`` interval, the companion frequency</span>
<span class="sd">        decreases exponentially with ``logp``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">exp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mf">0.3</span> <span class="o">*</span> <span class="p">(</span><span class="n">logp</span> <span class="o">-</span> <span class="mf">5.5</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">f_logp55_q03</span> <span class="o">*</span> <span class="n">exp</span>

<div class="viewcode-block" id="CompanionFrequencyDistributionHighQ.companion_frequency_q03">
<a class="viewcode-back" href="../../bossa.html#bossa.zams.CompanionFrequencyDistributionHighQ.companion_frequency_q03">[docs]</a>
    <span class="k">def</span> <span class="nf">companion_frequency_q03</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logp</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns companion frequency at ``0.3&lt;=q&lt;=1.0``, ``logp``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">logp</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">LOGP_BREAKS</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">logp</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">LOGP_BREAKS</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f1</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">logp</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">LOGP_BREAKS</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f2</span><span class="p">(</span><span class="n">logp</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">logp</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">LOGP_BREAKS</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f3</span><span class="p">(</span><span class="n">logp</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">logp</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">LOGP_BREAKS</span><span class="p">[</span><span class="mi">4</span><span class="p">]:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f4</span><span class="p">(</span><span class="n">logp</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">logp</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">LOGP_BREAKS</span><span class="p">[</span><span class="mi">5</span><span class="p">]:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_f5</span><span class="p">(</span><span class="n">logp</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">f</span></div>
</div>



<span class="c1"># TODO : Add Sana+2012 orbital period distribution</span>
<div class="viewcode-block" id="CompanionFrequencyDistribution">
<a class="viewcode-back" href="../../bossa.html#bossa.zams.CompanionFrequencyDistribution">[docs]</a>
<span class="k">class</span> <span class="nc">CompanionFrequencyDistribution</span><span class="p">(</span><span class="n">CompanionFrequencyDistributionHighQ</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Orbital period distribution for a ``0.1&lt;=q&lt;=1`` ZAMS star pair.</span>

<span class="sd">    For a primary of mass ``m1``, compute the log orbital period</span>
<span class="sd">    (``logp``) probability density function (PDF) for a companion with</span>
<span class="sd">    some mass ``m_cp`` such that ``0.3 &lt;= q &lt;= 1.0`` (``q=m_cp/m1``).</span>

<span class="sd">    Allows for either a strongly ``m1``- and ``logp``-dependent piecewise</span>
<span class="sd">    function of power-law, linear and exponential components; or a</span>
<span class="sd">    uniform on ``logp`` distribution.</span>

<span class="sd">    All orbital periods are given in days and masses in solar masses.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m1 : float</span>
<span class="sd">        Primary mass.</span>
<span class="sd">    q_distr : :class:`MassRatioDistribution`</span>
<span class="sd">        Mass ratio distribution for the same :attr:`m1`.</span>
<span class="sd">    uncorrelated : bool</span>
<span class="sd">        Whether to assume a correlated distribution or not.</span>
<span class="sd">    extrapolate_uncorrelated_distribution : bool</span>
<span class="sd">        If an uncorrelated distribution is assumed, whether to</span>
<span class="sd">        extrapolate it to the range of the correlated distribution.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    q_distr : :class:`MassRatioDistribution`</span>
<span class="sd">        Mass ratio distribution for the same :attr:`m1`.</span>
<span class="sd">    n_q03 : float</span>
<span class="sd">        Fraction of `0.3 &lt;= q &lt;= 1.0` star pairs with :attr:`m1`.</span>
<span class="sd">    n_q01 : float</span>
<span class="sd">        Fraction of `0.1 &lt;= q &lt; 0.3` star pairs with :attr:`m1`.</span>


<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The distribution is by Moe &amp; Di Stefano (2017) [1]_ and covers the</span>
<span class="sd">    0.2&lt;=logp&lt;=8` range. Most of the observational techniques considered</span>
<span class="sd">    therein are not able to probe pairs below `q=0.3`, and thus the</span>
<span class="sd">    period distribution is only empirically fitted to the `q&gt;0.3`</span>
<span class="sd">    region, yielding the distribution in</span>
<span class="sd">    :class:`CompanionFrequencyDistributionHighQ`.</span>

<span class="sd">    However, from the particular observations that do probe</span>
<span class="sd">    `0.1 &lt;= q &lt; 0.3`, they are able to empirically fit the mass ratio</span>
<span class="sd">    distribution in that region, in the form of</span>
<span class="sd">    :attr:`MassRatioDistribution.gamma_smallq`. Thus, from the</span>
<span class="sd">    integration of the mass ratio distribution it is possible to compute</span>
<span class="sd">    the ratio :attr:`n_q01`/:attr:`n_q03` between pairs above and below</span>
<span class="sd">    `q=0.3`.</span>

<span class="sd">    This class calculates that ratio, and uses it as a correction</span>
<span class="sd">    factor to obtain, from the companion frequency in</span>
<span class="sd">    ``0.3 &lt;= q &lt;= 1.0`` (:math:`f_{\\log P; q&gt;0.3}`), the companion</span>
<span class="sd">    frequency in ``0.1 &lt;= q &lt;= 1.0`` (:math:`f_{\\log P; q&gt;0.1}`).</span>

<span class="sd">    The uncorrelated distribution is a uniform on ``logp`` probability</span>
<span class="sd">    distribution between ``0.4`` and ``3``, or Öpik&#39;s law [3]_. The</span>
<span class="sd">    :attr:`extrapolate_uncorrelated_distribution` parameter allows</span>
<span class="sd">    extrapolating it to the same range as that of the correlated</span>
<span class="sd">    distribution.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [3] Öpik, E. (1924). Statistical Studies of Double Stars: On the</span>
<span class="sd">       Distribution of Relative Luminosities and Distances of Double</span>
<span class="sd">       Stars in the Harvard Revised Photometry North of Declination</span>
<span class="sd">       -31°. Publications of the Tartu Astrofizica Observatory, 25, 1.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">q_distr</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">uncorrelated</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">extrapolate_uncorrelated_distribution</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">m1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_distr</span> <span class="o">=</span> <span class="n">q_distr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_q03</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_q01</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">uncorrelated</span> <span class="o">=</span> <span class="n">uncorrelated</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate_uncorrelated_distribution</span> <span class="o">=</span> <span class="n">extrapolate_uncorrelated_distribution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_uncorrelated_prob_distribution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_uncorrelated_distribution</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_h1</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">x1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">x2</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return integral of x**a between x1 and x2.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x2</span> <span class="o">/</span> <span class="n">x1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">x2</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a</span><span class="p">)</span> <span class="o">-</span> <span class="n">x1</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_uncorrelated_distribution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">uniform</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the uncorrelated distribution.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">extrapolate_uncorrelated_distribution</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">uniform</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">8</span><span class="o">-</span><span class="mf">0.2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">uniform</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mf">0.4</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">3</span><span class="o">-</span><span class="mf">0.4</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_n_q03</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the relative number of ``0.3&lt;=q&lt;=1.0`` star pairs.&quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h1</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_distr</span><span class="o">.</span><span class="n">gamma_largeq</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">,</span> <span class="mf">1.00</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h1</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_distr</span><span class="o">.</span><span class="n">gamma_largeq</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_q03</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_distr</span><span class="o">.</span><span class="n">f_twin</span><span class="p">)</span> <span class="o">+</span> <span class="n">b</span>

    <span class="k">def</span> <span class="nf">_set_n_q01</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the relative number of ``0.1&lt;=q&lt;0.3`` star pairs.&quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_h1</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_distr</span><span class="o">.</span><span class="n">gamma_smallq</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)</span>
        <span class="n">continuity_factor</span> <span class="o">=</span> <span class="mf">0.3</span> <span class="o">**</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q_distr</span><span class="o">.</span><span class="n">gamma_largeq</span>
                                    <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_distr</span><span class="o">.</span><span class="n">gamma_smallq</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_q01</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_q03</span> <span class="o">+</span> <span class="n">continuity_factor</span> <span class="o">*</span> <span class="n">a</span>

<div class="viewcode-block" id="CompanionFrequencyDistribution.companion_frequency_q01">
<a class="viewcode-back" href="../../bossa.html#bossa.zams.CompanionFrequencyDistribution.companion_frequency_q01">[docs]</a>
    <span class="k">def</span> <span class="nf">companion_frequency_q01</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logp</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns companion frequency at ``0.1&lt;=q&lt;=1.0``, ``logp``.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">uncorrelated</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_uncorrelated_prob_distribution</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">logp</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">q_distr</span><span class="o">.</span><span class="n">set_parameters</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m1</span><span class="p">,</span> <span class="n">logp</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_n_q03</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_set_n_q01</span><span class="p">()</span>
            <span class="n">f03</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">companion_frequency_q03</span><span class="p">(</span><span class="n">logp</span><span class="p">)</span>
            <span class="n">f01</span> <span class="o">=</span> <span class="n">f03</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_q01</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_q03</span>
            <span class="k">return</span> <span class="n">f01</span></div>
</div>



<span class="c1"># TODO: add logger to MultipleFraction and replace print statements</span>
<div class="viewcode-block" id="MultipleFraction">
<a class="viewcode-back" href="../../bossa.html#bossa.zams.MultipleFraction">[docs]</a>
<span class="k">class</span> <span class="nc">MultipleFraction</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Multiplicity fractions as a function of primary mass.</span>

<span class="sd">    For a given primary mass ``m1``, compute the probability of having</span>
<span class="sd">    ``n`` companions in `` 0.1 &lt;= q &lt;= 1.0`` pairs. The probability</span>
<span class="sd">    distribution over ``n`` is discrete, and takes the form of a</span>
<span class="sd">    truncated Poisson distribution.</span>

<span class="sd">    Can return individual multiplicity fractions for up to :attr:`nmax`</span>
<span class="sd">    companions, or compute a binary fraction by assuming all</span>
<span class="sd">    non-isolated stars are in binaries.</span>

<span class="sd">    All masses are in solar masses.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mmin : float</span>
<span class="sd">        Minimum primary mass.</span>
<span class="sd">    mmax : float</span>
<span class="sd">        Maximum primary mass.</span>
<span class="sd">    nmax : float</span>
<span class="sd">        Maximum companion number.</span>
<span class="sd">    nmean_max : float</span>
<span class="sd">        Maximum mean companion number, for interpolation.</span>
<span class="sd">    only_binaries : bool</span>
<span class="sd">        Whether to assume all non-isolated stars are in binaries.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    q_distr : :class:`MassRatioDistribution`</span>
<span class="sd">        Necessary to set up the companion frequency distributions.</span>
<span class="sd">    m1_array : NDArray</span>
<span class="sd">        Primary masses to set up the companion frequency distributions.</span>
<span class="sd">    nmean_array : NDArray</span>
<span class="sd">        Mean companion numbers corresponding to the masses in</span>
<span class="sd">        :attr:`m1_array`.</span>
<span class="sd">    binary_fraction : NDArray</span>
<span class="sd">        Binary fractions corresponding to the primary masses in</span>
<span class="sd">        :attr:``m1_array``, when all stars are isolated or binaries.</span>
<span class="sd">    multfreq_to_nmean : scipy.interpolate.interp1d</span>
<span class="sd">        Multiplicity frequency to mean companion number interpolator.</span>
<span class="sd">    m1_to_nmean : scipy.interpolate.interp1d</span>
<span class="sd">        Primary mass to mean companion number interpolator.</span>
<span class="sd">    nmax : float</span>
<span class="sd">        Maximum companion number.</span>
<span class="sd">    nmean_max : float</span>
<span class="sd">        Maximum mean companion number, used for interpolation only.</span>

<span class="sd">    Warns</span>
<span class="sd">    -----</span>
<span class="sd">    UserWarning</span>
<span class="sd">        If :meth:`ncomp_mean` is called before :meth:`solve`.</span>

<span class="sd">    See Also</span>
<span class="sd">    -------</span>
<span class="sd">    CompanionFrequencyDistribution :</span>
<span class="sd">        Its correlated model is the source of the multiplicity fractions</span>
<span class="sd">        as a function of mass.</span>
<span class="sd">    sampling.SimpleBinaryPopulation :</span>
<span class="sd">        Implements this class to generate a full ZAMS binary population.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This class computes multiplicity fractions as suggested by Moe &amp; Di</span>
<span class="sd">    Stefano (2017) [1]_, but for a general case, as described in de Sá</span>
<span class="sd">    et al. (submitted). Computation starts from the companion frequency</span>
<span class="sd">    distributed as in :class:`CompanionFrequencyDistribution`.</span>
<span class="sd">    The number of companions per primary (multiplicity frequency) is</span>
<span class="sd">    given by integrating the companion frequency over orbital period,</span>

<span class="sd">    .. math::</span>

<span class="sd">        f_\\mathrm{mult}(M_1) = \\int_{0.2}^{0.8} d\\log P\\,</span>
<span class="sd">        f_{\\log P; q&gt;0.3}(M_1,\\log P).</span>

<span class="sd">    The multiplicity fraction, :math:`F_n`, is defined as the fraction</span>
<span class="sd">    of all primaries with a number :math:`n` of companions. These relate</span>
<span class="sd">    to the multiplicity frequency as:</span>

<span class="sd">    .. math::</span>

<span class="sd">        f_\\mathrm{mult}(M_1) = F_1(M_1) + 2F_2(M_1) + 3F_3(M_1) + ...,</span>

<span class="sd">    for a primary mass :math:`M_1`. The :math:`F_n` are not, in general,</span>
<span class="sd">    empirically constrained. This class follows Moe &amp; Di Stefano (2017)</span>
<span class="sd">    [1]_ in extending the observed behavior for solar-type primaries to</span>
<span class="sd">    all primaries. In this case, the number of companions is observed</span>
<span class="sd">    to be distributed over :math:`M_1` in the form of a Poissonian</span>
<span class="sd">    distribution, with a :math:`M_1`-dependent mean</span>
<span class="sd">    :math:`n_\\mathrm{mean}` fully determined by imposing the empirical</span>
<span class="sd">    :math:`f_\\mathrm{mult}(M_1)` as a constraint.</span>

<span class="sd">    By assuming a Poissonian truncated at :attr:`nmax`, the companion</span>
<span class="sd">    number n is distributed as</span>

<span class="sd">    .. math::</span>

<span class="sd">        P_n(M_1) = \\left( \\sum_{ n=0 }^{ n_\\mathrm{max} }</span>
<span class="sd">        \\frac{n_\\mathrm{mean}^n}{n!} \\right)^{-1}</span>
<span class="sd">        \\frac{n_\\mathrm{mean}^{n}}{n!},</span>

<span class="sd">    and :math:`F_n(M_1) = P_n(M_1)`. Then, from the definition of</span>
<span class="sd">    :math:`P_n` and the :math:`f_\\mathrm{mult}-F_n` relation,</span>
<span class="sd">    :math:`f_\\mathrm{mult}` is written as</span>

<span class="sd">    .. math::</span>

<span class="sd">        f_\\mathrm{mult}(n_\\mathrm{mean}) =</span>
<span class="sd">       \\frac{n_\\mathrm{mean}}{1 + a/b},</span>

<span class="sd">    with</span>

<span class="sd">    .. math::</span>

<span class="sd">        a = {n_\\mathrm{mean}}^{n_\\mathrm{max}} n_\\mathrm{max}!,</span>

<span class="sd">    and</span>

<span class="sd">    .. math::</span>

<span class="sd">        b = \\sum_{ n=0 }^{ n_\\mathrm{max}-1 }</span>
<span class="sd">        \\frac{{n_\\mathrm{mean}}^n}{n!}.</span>

<span class="sd">    From this relation an array of</span>
<span class="sd">    :math:`(f_\\mathrm{mult}, n_\\mathrm{mean})` pairs is calculated,</span>
<span class="sd">    and from it a :math:`f_\\mathrm{mult}` to :math:`n_\\mathrm{mean}`</span>
<span class="sd">    interpolator is built. :math:`f_\\mathrm{mult}` is then determined</span>
<span class="sd">    by integrating the companion frequency for a given mass, as per its</span>
<span class="sd">    definition. This is done for masses :attr:`m1_array`, and the</span>
<span class="sd">    resulting :math:`(m_1, f_\\mathrm{mult})` array yields a</span>
<span class="sd">    :math:`(m_1, n_\\mathrm{mean})` array through the above</span>
<span class="sd">    interpolator. A second, :math:`m_1` to :math:`n_\\mathrm{mean}`,</span>
<span class="sd">    interpolator is then built.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mmin</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span> <span class="n">mmax</span> <span class="p">:</span> <span class="nb">float</span>  <span class="o">=</span> <span class="mf">150.</span><span class="p">,</span> <span class="n">nmax</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
                 <span class="n">nmean_max</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">11</span><span class="p">,</span> <span class="n">only_binaries</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">q_distr</span> <span class="o">=</span> <span class="n">MassRatioDistribution</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mmin</span> <span class="o">=</span> <span class="n">mmin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mmax</span> <span class="o">=</span> <span class="n">mmax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m1_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nmean_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m1_array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binary_fraction</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m1_array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">multfreq_to_nmean</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m1_to_nmean</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nmax</span> <span class="o">=</span> <span class="n">nmax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nmean_max</span> <span class="o">=</span> <span class="n">nmean_max</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">only_binaries</span> <span class="o">=</span> <span class="n">only_binaries</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_truncated_poisson_mdf</span><span class="p">(</span><span class="n">l</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">k_arr</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">NDArray</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">k_max</span><span class="p">:</span> <span class="nb">int</span>
                               <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Evaluate a Poissonian distribution.</span>

<span class="sd">        Returns the value at ``k`` of a Poissonian distribution with</span>
<span class="sd">        mean ``l`` and truncated at ``k_max``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">k_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">k_arr</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">k_max</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">distr</span> <span class="o">=</span> <span class="n">poisson</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
                <span class="n">norm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">distr</span><span class="o">.</span><span class="n">pmf</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">k_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)))</span>
                <span class="n">probs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">distr</span><span class="o">.</span><span class="n">pmf</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">/</span> <span class="n">norm</span>
        <span class="k">return</span> <span class="n">probs</span>

    <span class="k">def</span> <span class="nf">_nmean_to_multfreq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nmean</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the multiplicity frequency corresponding to ``nmean``.</span>

<span class="sd">        By assuming that the companion number ``n`` is distributed as a</span>
<span class="sd">        Poissonian with mean ``nmean``, truncated at :attr:`nmax`, the</span>
<span class="sd">        multiplicity frequency can be computed analytically.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">b</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmax</span><span class="p">):</span>
            <span class="n">b</span> <span class="o">+=</span> <span class="n">nmean</span> <span class="o">**</span> <span class="n">n</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">nmean</span> <span class="o">**</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmax</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">math</span><span class="o">.</span><span class="n">factorial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmax</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">nmean</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">a</span><span class="o">/</span><span class="n">b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_m1_to_multfreq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m1</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the multiplicity frequency corresponding to ``m1``.</span>

<span class="sd">        Integrating the companion frequency at ``m1`` over orbital</span>
<span class="sd">        period yields the multiplicty frequency at ``m1``.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">freq_distr</span> <span class="o">=</span> <span class="n">CompanionFrequencyDistribution</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_distr</span><span class="p">)</span>
        <span class="n">multfreq</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">logp0</span><span class="p">,</span> <span class="n">logp1</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">freq_distr</span><span class="o">.</span><span class="n">LOGP_BREAKS</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">freq_distr</span><span class="o">.</span><span class="n">LOGP_BREAKS</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">multfreq</span> <span class="o">+=</span> <span class="n">quad</span><span class="p">(</span><span class="n">freq_distr</span><span class="o">.</span><span class="n">companion_frequency_q01</span><span class="p">,</span> <span class="n">logp0</span><span class="p">,</span> <span class="n">logp1</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mi">100</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">multfreq</span>

    <span class="k">def</span> <span class="nf">_set_m1_to_nmean</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Setup a ``m1`` to ``nmean`` interpolator.</span>

<span class="sd">        First computes the multiplicity frequencies for :attr:`m1_array`</span>
<span class="sd">        with :meth:`_m1_to_multfreq`, then the corresponding ``nmean``</span>
<span class="sd">        with :attr:`multfreq_to_nmean`. Finally, the :attr:`m1_to_nmean`</span>
<span class="sd">        interpolator is set.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Setting up M1 to companion Nmean interpolator...&#39;</span><span class="p">)</span>
        <span class="n">time0</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span>
        <span class="n">multfreqs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_m1_to_multfreq</span><span class="p">(</span><span class="n">m1</span><span class="p">)</span> <span class="k">for</span> <span class="n">m1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">m1_array</span><span class="p">]</span>
        <span class="n">nmeans</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">multfreq_to_nmean</span><span class="p">(</span><span class="n">multfreq</span><span class="p">)</span> <span class="k">for</span> <span class="n">multfreq</span> <span class="ow">in</span> <span class="n">multfreqs</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m1_to_nmean</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m1_array</span><span class="p">,</span> <span class="n">nmeans</span><span class="p">)</span>
        <span class="n">time1</span> <span class="o">=</span> <span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">time0</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Done setting up interpolator. &#39;</span>
              <span class="sa">f</span><span class="s1">&#39;Elapsed time: </span><span class="si">{</span><span class="n">time1</span><span class="si">:</span><span class="s1">.4f</span><span class="si">}</span><span class="s1"> s.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_multfreq_to_nmean</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Setup multiplicity frequency to ``nmean`` interpolator.&quot;&quot;&quot;</span>
        <span class="n">nmeans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmean_max</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
        <span class="n">multfreqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_nmean_to_multfreq</span><span class="p">(</span><span class="n">nmean</span><span class="p">)</span> <span class="k">for</span> <span class="n">nmean</span> <span class="ow">in</span> <span class="n">nmeans</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">multfreq_to_nmean</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">multfreqs</span><span class="p">,</span> <span class="n">nmeans</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_mmax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the maximum mass and mass array.</span>

<span class="sd">        The maximum mass is set to either 150.0 or to the maximum mass</span>
<span class="sd">        allowed by :attr:`nmean_max`, whichever is greater. The greater</span>
<span class="sd">        the :attr:`nmean_max`, the more massive primaries can be allowed</span>
<span class="sd">        by the multiplicity frequency constraint. :attr:`m1_array` is</span>
<span class="sd">        then set for :attr:`mmax`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmax</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mmax</span> <span class="o">=</span> <span class="mf">150.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">m1_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mmin</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mmax</span><span class="p">),</span> <span class="mi">20</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">m1_array</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mmax</span>
            <span class="k">return</span>
        <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">m1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">m1</span> <span class="o">&lt;</span> <span class="mf">0.8</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1e3</span><span class="p">)</span>
            <span class="n">multfreq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_m1_to_multfreq</span><span class="p">(</span><span class="n">m1</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">nmean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">multfreq_to_nmean</span><span class="p">(</span><span class="n">multfreq</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">nmean</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">1e4</span><span class="p">)</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">nmean</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmean_max</span><span class="p">)</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="mf">1e4</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="mi">100</span>
        <span class="n">tries</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">max_tries</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="k">while</span> <span class="n">diff</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">tries</span> <span class="o">&lt;</span> <span class="n">max_tries</span><span class="p">:</span>
            <span class="n">mmax</span><span class="p">,</span> <span class="n">diff</span><span class="p">,</span> <span class="o">*</span><span class="n">_</span> <span class="o">=</span> <span class="n">fmin</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">x0</span><span class="p">,</span> <span class="n">full_output</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">disp</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">x0</span> <span class="o">/=</span> <span class="mi">2</span>
            <span class="n">tries</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mmax</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">mmax</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mmax</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m1_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mmin</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mmax</span><span class="p">),</span> <span class="mi">20</span><span class="p">)</span>
        <span class="c1"># avoid error from an implicit 10**np.log10(mmax)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m1_array</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mmax</span>

<div class="viewcode-block" id="MultipleFraction.solve">
<a class="viewcode-back" href="../../bossa.html#bossa.zams.MultipleFraction.solve">[docs]</a>
    <span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set up companion number probability distribution.</span>

<span class="sd">        Sets up a series of interpolators necessary for computing the</span>
<span class="sd">        companion number as a function of mean companion number and</span>
<span class="sd">        primary mass. Defines :attr:`m1_array` and the corresponding</span>
<span class="sd">        :attr:`nmean_array` and :attr:`binary_fraction`, and is</span>
<span class="sd">        necessary for :meth:`ncomp_mean` and</span>
<span class="sd">        :meth:`get_multiple_fraction`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_multfreq_to_nmean</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_mmax</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_m1_to_nmean</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">m1</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m1_array</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">nmean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m1_to_nmean</span><span class="p">(</span><span class="n">m1</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">m1_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m1_array</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nmean_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmean_array</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">binary_fraction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binary_fraction</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nmean_array</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nmean</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m1_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m1_array</span><span class="p">[:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nmean_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmean_array</span><span class="p">[:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">binary_fraction</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binary_fraction</span><span class="p">[:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="MultipleFraction.ncomp_mean">
<a class="viewcode-back" href="../../bossa.html#bossa.zams.MultipleFraction.ncomp_mean">[docs]</a>
    <span class="k">def</span> <span class="nf">ncomp_mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m1</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return mean companion number for a primary mass ``m1``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        m1 : float</span>
<span class="sd">            Primary mass.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            Mean companion number.</span>

<span class="sd">        Warns</span>
<span class="sd">        -----</span>
<span class="sd">        UserWarning</span>
<span class="sd">            If :meth:`solve` has not been called yet.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">m1_to_nmean</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;m1 to nmean interpolator not set up. &#39;</span>
                          <span class="s1">&#39;Please run solve() first.&#39;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">m1_to_nmean</span><span class="p">(</span><span class="n">m1</span><span class="p">)</span></div>


<div class="viewcode-block" id="MultipleFraction.prob">
<a class="viewcode-back" href="../../bossa.html#bossa.zams.MultipleFraction.prob">[docs]</a>
    <span class="k">def</span> <span class="nf">prob</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">|</span> <span class="n">NDArray</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">|</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return probability of ``k`` companions given mean ``l``.&quot;&quot;&quot;</span>
        <span class="n">k_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">prob_arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">k_arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">probs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_truncated_poisson_mdf</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">k_arr</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmax</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">only_binaries</span><span class="p">:</span>
            <span class="n">prob_arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">probs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">prob_arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">probs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prob_arr</span> <span class="o">=</span> <span class="n">probs</span>
        <span class="k">return</span> <span class="n">prob_arr</span></div>


<div class="viewcode-block" id="MultipleFraction.get_multiple_fraction">
<a class="viewcode-back" href="../../bossa.html#bossa.zams.MultipleFraction.get_multiple_fraction">[docs]</a>
    <span class="k">def</span> <span class="nf">get_multiple_fraction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return fraction of order n multiples for :attr:`m1_array`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n : int</span>
<span class="sd">            Companion number.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fracs : NDArray</span>
<span class="sd">            ``(len(m1_array),)``-shaped array containing the n-multiplicity</span>
<span class="sd">            fractions for masses in ::meth:`m1_array`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">fracs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmean_array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">nmean</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nmean_array</span><span class="p">):</span>
            <span class="n">frac</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_truncated_poisson_mdf</span><span class="p">(</span><span class="n">nmean</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nmax</span><span class="p">)</span>
            <span class="n">fracs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">frac</span>
        <span class="n">fracs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fracs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">fracs</span></div>
</div>



<span class="c1"># TODO: import tables for proper File, Group, etc. typing</span>
<div class="viewcode-block" id="ZAMSSystemGenerator">
<a class="viewcode-back" href="../../bossa.html#bossa.zams.ZAMSSystemGenerator">[docs]</a>
<span class="k">class</span> <span class="nc">ZAMSSystemGenerator</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate ZAMS multiples from a shared mass pool.</span>

<span class="sd">    Receives an array of pre-sampled initial masses :attr:`imf_array`</span>
<span class="sd">    from which all masses (primary and of companions) are drawn without</span>
<span class="sd">    repetition. Builds zero-age main sequence (ZAMS) multiples by</span>
<span class="sd">    randomly pulling a primary mass from the pool, drawing a companion</span>
<span class="sd">    number; then for each companion drawing its mass from a mass ratio</span>
<span class="sd">    distribution, and looking for the closest match in</span>
<span class="sd">    :attr:`imf_array`, which is accepted if the relative difference</span>
<span class="sd">    between masses is at most :attr:`dmcomp_tol`. Orbital period and</span>
<span class="sd">    eccentricity are drawn from their respective distributions. Allows</span>
<span class="sd">    the user to pull one system at a time until the mass pool is</span>
<span class="sd">    exhausted or becomes unable to produce valid mass pairings. The mass</span>
<span class="sd">    pool allows the sample to follow an arbitrary initial mass function</span>
<span class="sd">    (IMF).</span>

<span class="sd">    All orbital periods are in days and masses in solar masses.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    imf_array : numpy array</span>
<span class="sd">        Array from which to sample primary and companion masses.</span>
<span class="sd">    pairs_table_path : path_like, \</span>
<span class="sd">    default : :data:`constants.BINARIES_UNCORRELATED_TABLE_PATH`</span>
<span class="sd">        Path to a HDF5 file containing equiprobable (m1,logp,q,e) sets</span>
<span class="sd">        according to the desired orbital parameter distributions.</span>
<span class="sd">    m1_min : float, default : 0.8</span>
<span class="sd">        Minimum primary mass.</span>
<span class="sd">    qe_max_tries : int, default : 1</span>
<span class="sd">        Maximum number of attempts at drawing a valid ``q,e`` pair for</span>
<span class="sd">        a given ``m1,logp``, before ``m1`` is redrawn.</span>
<span class="sd">    dmcomp_tol : float, default : 0.05</span>
<span class="sd">        Maximum accepted difference between a companion mass drawn from</span>
<span class="sd">        a `q`-distribution and the closest value in :attr:`imf_array`,</span>
<span class="sd">        relative to the latter.</span>
<span class="sd">    parent_logger : logging Logger, default : None</span>
<span class="sd">        Logger of the class or module from which this class was</span>
<span class="sd">        instantiated.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    pairs_table_path : path_like</span>
<span class="sd">        Path to a HDF5 file containing equiprobable (m1,logp,q,e) sets</span>
<span class="sd">        according to the desired orbital parameter distributions.</span>
<span class="sd">    imf_array : NDArray</span>
<span class="sd">        Array from which to sample primary and companion masses.</span>
<span class="sd">    m1_min : float</span>
<span class="sd">        Minimum primary mass.</span>
<span class="sd">    qe_max_tries : int</span>
<span class="sd">        Maximum number of attempts at drawing a valid ``q,e`` pair for</span>
<span class="sd">        a given ``m1,logp``, before ``m1`` is redrawn.</span>
<span class="sd">    dmcomp_tol : float</span>
<span class="sd">        Maximum accepted difference between a companion mass drawn from</span>
<span class="sd">        a `q`-distribution and the closest value in :attr:`imf_array`,</span>
<span class="sd">        relative to the latter.</span>
<span class="sd">    pairs_table : tables.File</span>
<span class="sd">        Table loaded from :attr:`pairs_table_path`</span>
<span class="sd">    lowmass_imf_array : NDArray</span>
<span class="sd">        Subarray of :attr:`imf_array` below :attr:`m1_min`.</span>
<span class="sd">    highmass_imf_array : numpy array</span>
<span class="sd">        Subarray of :attr:`imf_array` above :attr:`m1_min`.</span>
<span class="sd">    m1array_n : int</span>
<span class="sd">        Live length of :attr:`highmass_imf_array`.</span>
<span class="sd">    m1array_i : int</span>
<span class="sd">        Index of the last ``m1`` drawn from :attr:`highmass_imf_array`.</span>
<span class="sd">    m1_array : float32</span>
<span class="sd">        Last ``m1`` drawn from :attr:`highmass_imf_array`.</span>
<span class="sd">    m1_table : float32</span>
<span class="sd">        Closest match to :attr:`m1_array` in :attr:`pairs_table`.</span>
<span class="sd">    dm1 : float</span>
<span class="sd">        Difference between :attr:`m1_table` and :attr:`m1_array`</span>
<span class="sd">        relative to the latter.</span>
<span class="sd">    m1group : tables.Group</span>
<span class="sd">        Table of equiprobable companions for :attr:`m1_table`,</span>
<span class="sd">        identified by a set ``(logp,q,e)``.</span>
<span class="sd">    logger : logging.Logger</span>
<span class="sd">        Instance logger.</span>

<span class="sd">    See Also</span>
<span class="sd">    -------</span>
<span class="sd">    sampling.SimpleBinaryPopulation :</span>
<span class="sd">        Implements this class to generate a binary population.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This class allow for sampling multiples of arbitrary order, but it</span>
<span class="sd">    assumes that table :attr:`pairs_table` was built based on</span>
<span class="sd">    distributions appropriate for the desired degree of multiplicity.</span>
<span class="sd">    All companion masses are always removed from :attr:`imf_array` upon</span>
<span class="sd">    a successful draw.</span>

<span class="sd">    Within triples or higher-order multiples, all orbital periods are</span>
<span class="sd">    drawn simultaneously, i.e., the orbital periods of individual</span>
<span class="sd">    companions are not treated as independent quantities. Orbital</span>
<span class="sd">    parameters are ordered in order of closest farthest companion in</span>
<span class="sd">    the output of :meth:`sample_system`, to allow evolving only the</span>
<span class="sd">    inner binary. Note that this shifts the binary orbital period</span>
<span class="sd">    distribution to lower periods, as discussed in de Sá et al. [2]_.</span>

<span class="sd">    Ultimately, orbital periods, mass ratios and eccentricities will be</span>
<span class="sd">    limited to the values in :attr:`pairs_table`, while both</span>
<span class="sd">    :attr:`m1_table` and :attr:`m1_array` are returned by</span>
<span class="sd">    :meth:`sample_system`. It is expected that the table is composed of</span>
<span class="sd">    root-level groups, each of which corresponds to a primary mass; and</span>
<span class="sd">    that each :attr:`m1group` is composed of tables, each of which</span>
<span class="sd">    corresponding to a `logp` and containing mass ratio-eccentricity</span>
<span class="sd">    pairs. It is expected that all combinations of the four parameters</span>
<span class="sd">    found in the table are equiprobable. By default, this class loads</span>
<span class="sd">    tables from :data:`constants.BINARIES_UNCORRELATED_TABLE_PATH`.</span>
<span class="sd">    Check its documentation for description on its construction.</span>

<span class="sd">    This class can be employed on its own to generate individual systems.</span>
<span class="sd">    Its implementation for the generation of an entire sample of</span>
<span class="sd">    binaries is handled by the :class:`sampling.SimpleBinaryPopulation`</span>
<span class="sd">    class.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; systemgenerator = ZAMSSystemGenerator(imf_array=np.logspace(-1, 2, int(1e6)))</span>
<span class="sd">    &gt;&gt;&gt; systemgenerator.setup_sampler()</span>
<span class="sd">    &gt;&gt;&gt; m1table_indices = np.random.randint(0, systemgenerator.m1array_n, 2)</span>
<span class="sd">    &gt;&gt;&gt; systemgenerator.open_m1group(m1table_indices[0])</span>
<span class="sd">    &gt;&gt;&gt; sampled_pairs1 = systemgenerator.sample_system(ncomp=1, ncomp_max=2)</span>
<span class="sd">    &gt;&gt;&gt; systemgenerator.open_m1group(m1table_indices[1])</span>
<span class="sd">    &gt;&gt;&gt; sampled_pairs2 = systemgenerator.sample_system(ncomp=2, ncomp_max=2)</span>
<span class="sd">    &gt;&gt;&gt; systemgenerator.close_pairs_table()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">imf_array</span><span class="p">:</span> <span class="n">NDArray</span><span class="p">,</span>
                 <span class="n">pairs_table_path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="n">PathLike</span> <span class="o">=</span> <span class="n">BINARIES_UNCORRELATED_TABLE_PATH</span><span class="p">,</span>
                 <span class="n">m1_min</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.8</span><span class="p">,</span> <span class="n">qe_max_tries</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">dmcomp_tol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span>
                 <span class="n">parent_logger</span><span class="p">:</span> <span class="n">logging</span><span class="o">.</span><span class="n">Logger</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pairs_table_path</span> <span class="o">=</span> <span class="n">pairs_table_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">imf_array</span> <span class="o">=</span> <span class="n">imf_array</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m1_min</span> <span class="o">=</span> <span class="n">m1_min</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qe_max_tries</span> <span class="o">=</span> <span class="n">qe_max_tries</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dmcomp_tol</span> <span class="o">=</span> <span class="n">dmcomp_tol</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pairs_table</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lowmass_imf_array</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">highmass_imf_array</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m1array_n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m1array_i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m1_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m1_table</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dm1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m1group</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">logger</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_logger</span><span class="p">(</span><span class="n">parent_logger</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_logger</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent_logger</span><span class="p">:</span> <span class="n">logging</span><span class="o">.</span><span class="n">Logger</span> <span class="o">|</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">logging</span><span class="o">.</span><span class="n">Logger</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create and return a class logger.</span>

<span class="sd">        Will be a child of ``parent_logger`` if provided.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">parent_logger</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">loggername</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">])</span>
            <span class="n">log_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">LOG_PATH</span><span class="p">,</span>
                            <span class="n">loggername</span><span class="p">,</span>
                            <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1">-%m-%Y_%H:%M:%S.log&#39;</span><span class="p">))</span>
            <span class="n">log_path</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">mkdir</span><span class="p">(</span><span class="n">parents</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">logger</span> <span class="o">=</span> <span class="n">create_logger</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">loggername</span><span class="p">,</span> <span class="n">fpath</span><span class="o">=</span><span class="n">log_path</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">loggername</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">parent_logger</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">])</span>
            <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">loggername</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">logger</span>

    <span class="k">def</span> <span class="nf">_set_m1array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set :attr:`m1array_i` and :attr:`m1_array`.</span>

<span class="sd">        `index` should be less than :attr:`m1array_n`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">m1array_i</span> <span class="o">=</span> <span class="n">index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m1_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">highmass_imf_array</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_set_m1_options</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Load mass options from :attr:`pairs_table`.</span>

<span class="sd">        The primary mass corresponding to each group in</span>
<span class="sd">        :attr:`pairs_table` is expected to be the group&#39;s title. Loads</span>
<span class="sd">        the mass values into :attr:`_m1_options`, and the corresponding</span>
<span class="sd">        groups themselves into :attr:`_m1group_options`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">m1group_options</span> <span class="o">=</span> <span class="nb">list</span><span class="p">((</span><span class="n">group</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pairs_table</span><span class="o">.</span><span class="n">root</span><span class="p">[</span><span class="n">group</span><span class="p">]</span><span class="o">.</span><span class="n">_v_title</span><span class="p">)</span>
                               <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pairs_table</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">_v_groups</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_m1group_options</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">m1group_options</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_m1_options</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">group</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">m1group_options</span><span class="p">])</span>
        <span class="n">m1sort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_m1_options</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_m1group_options</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_m1group_options</span><span class="p">[</span><span class="n">m1sort</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_m1_options</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_m1_options</span><span class="p">[</span><span class="n">m1sort</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_get_m1</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">tables</span><span class="o">.</span><span class="n">Group</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns table mass and group closest to :attr:`m1_array`.&quot;&quot;&quot;</span>
        <span class="n">m1_closest_i</span><span class="p">,</span> <span class="n">m1_closest</span> <span class="o">=</span> <span class="n">valley_minimum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_m1_options</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">m1_array</span><span class="p">),</span>
                                                  <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_m1_options</span><span class="p">),</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">m1groupname_closest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_m1group_options</span><span class="p">[</span><span class="n">m1_closest_i</span><span class="p">]</span>
        <span class="n">m1_closest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_m1_options</span><span class="p">[</span><span class="n">m1_closest_i</span><span class="p">]</span>
        <span class="n">m1group_closest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pairs_table</span><span class="o">.</span><span class="n">root</span><span class="p">[</span><span class="n">m1groupname_closest</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">m1_closest</span><span class="p">,</span> <span class="n">m1group_closest</span>

<div class="viewcode-block" id="ZAMSSystemGenerator.setup_sampler">
<a class="viewcode-back" href="../../bossa.html#bossa.zams.ZAMSSystemGenerator.setup_sampler">[docs]</a>
    <span class="k">def</span> <span class="nf">setup_sampler</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set up attributes for the sampler.</span>

<span class="sd">        Loads data from :attr:`table_path`. Sets two mass sub-arrays,</span>
<span class="sd">        :attr:`lowmass_imf_array` and :attr:`highmass_imf_array`, to</span>
<span class="sd">        speed up sampling by assuming that `m1` is always in</span>
<span class="sd">        :attr:`highmass_imf_array` and that</span>
<span class="sd">        :math:`m_\\mathrm{comp}&lt;m_1`. Sets the initial value of</span>
<span class="sd">        :attr:`m1array_n`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">lowmass_imf_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imf_array</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">imf_array</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">m1_min</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">highmass_imf_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">imf_array</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">imf_array</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m1_min</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m1array_n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">highmass_imf_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pairs_table</span> <span class="o">=</span> <span class="n">tb</span><span class="o">.</span><span class="n">open_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pairs_table_path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_set_m1_options</span><span class="p">()</span></div>


<div class="viewcode-block" id="ZAMSSystemGenerator.close_pairs_table">
<a class="viewcode-back" href="../../bossa.html#bossa.zams.ZAMSSystemGenerator.close_pairs_table">[docs]</a>
    <span class="k">def</span> <span class="nf">close_pairs_table</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Close the :attr:`pairs_table` file.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pairs_table</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


<div class="viewcode-block" id="ZAMSSystemGenerator.open_m1group">
<a class="viewcode-back" href="../../bossa.html#bossa.zams.ZAMSSystemGenerator.open_m1group">[docs]</a>
    <span class="k">def</span> <span class="nf">open_m1group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the primary mass and open the corresponding group.</span>

<span class="sd">        Sets :attr:`m1_array` to the the element of</span>
<span class="sd">        :attr:`highmass_imf_array` at ``index`` and sets</span>
<span class="sd">        :attr:`m1_table`, :attr:`m1group` and :attr:`dm1`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_set_m1array</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">m1_table</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m1group</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_m1</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dm1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m1_table</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">m1_array</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">m1_array</span></div>


<div class="viewcode-block" id="ZAMSSystemGenerator.sample_system">
<a class="viewcode-back" href="../../bossa.html#bossa.zams.ZAMSSystemGenerator.sample_system">[docs]</a>
    <span class="k">def</span> <span class="nf">sample_system</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ncomp_max</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NDArray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return parameters of a multiple system.</span>

<span class="sd">        Generates a multiple system with ``ncomp`` companions for</span>
<span class="sd">        a primary set with :meth:`open_m1group`, assuming up to</span>
<span class="sd">        ``ncomp_max`` companions are allowed. Returns ordered inner</span>
<span class="sd">        binary and further pair parameters, as well as companion number</span>
<span class="sd">        and total system mass.</span>

<span class="sd">        ``ncomp_max`` is used for proper output formatting only.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ncomp : int, default : 1</span>
<span class="sd">            Number of companions to the primary. Can be 0 (isolated).</span>
<span class="sd">        ncomp_max : int, default : 1</span>
<span class="sd">            Maximum number of companions in the underlying population.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sample_pairs : NDArray</span>
<span class="sd">            ``(12+4*ncomp_max,)``-shaped array of 12 inner binary</span>
<span class="sd">            parameters and 4 parameters per further companion.</span>

<span class="sd">        Warns</span>
<span class="sd">        -----</span>
<span class="sd">        UserWarning</span>
<span class="sd">            If the system fails to be generated.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        For primary masses set with :meth:`open_m1group`, the orbital</span>
<span class="sd">        period logs ``logp_table`` are drawn for all ```ncomp``` binaries</span>
<span class="sd">        from :attr:`m1group`. Then, starting from the innermost</span>
<span class="sd">        companion and moving toward the outermost one, the corresponding</span>
<span class="sd">        ``logp_table`` table is opened in :attr:`m1group` and a</span>
<span class="sd">        ``q_table,e_table`` pair is drawn from it. The companion mass is</span>
<span class="sd">        set to ``mcomp_table=q_table*m1_table``, and its closest match in</span>
<span class="sd">        :attr:`imf_array`, ``mcomp_array``, is found. The drawn pair is</span>
<span class="sd">        tested against :attr:`dmcomp_tol`, and if</span>

<span class="sd">        .. math::</span>

<span class="sd">            \\frac{|m_\\mathrm{comp}^\\mathrm{array}-m_\\mathrm{table}|}</span>
<span class="sd">            {m_\\mathrm{comp}^\\mathrm{array}} \\leq</span>
<span class="sd">            dm_\\mathrm{comp}^\\mathrm{tol},</span>

<span class="sd">        the pair is accepted. If not, ``q,e`` can be drawn for up to</span>
<span class="sd">        :attr:`qe_max_tries` times. If no match can be found, the draw</span>
<span class="sd">        failed, and an empty parameter array is returned.</span>

<span class="sd">        If at any point a valid pair fails to be found, the whole system</span>
<span class="sd">        is discarded and an empty array is returned. Otherwise, the</span>
<span class="sd">        parameters for the sampled pairs are returned, and the component</span>
<span class="sd">        masses are removed from the :attr:`imf_array` and its</span>
<span class="sd">        sub-arrays.</span>

<span class="sd">        The 12 first output columns are  [Table primary mass,</span>
<span class="sd">        Array primary mass, Relative m1 difference,</span>
<span class="sd">        Table secondary mass, Array secondary mass,</span>
<span class="sd">        Relative m2 difference, Mass ratio from table masses,</span>
<span class="sd">        Mass ratio from array masses, log10(orbital period),</span>
<span class="sd">        Eccentricity, Companion number, Total system mass].</span>

<span class="sd">        Each further companion appends 4 more columns to the output.</span>
<span class="sd">        They are [Table companion mass, Array companion mass,</span>
<span class="sd">        log10(orbital period), Eccentricity].</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Check if there are enough masses available.</span>
        <span class="k">if</span> <span class="n">ncomp</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lowmass_imf_array</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">highmass_imf_array</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">m1array_i</span><span class="p">]):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># System mass starts with the primary mass.</span>
        <span class="n">system_mass</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m1_table</span>

        <span class="c1"># System parameters to be returned are NOT CUSTOMIZABLE at the</span>
        <span class="c1"># moment. A specific length and order for the arrays below</span>
        <span class="c1"># is assumed here and in the sampling module.</span>
        <span class="n">outer_pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">ncomp_max</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
        <span class="n">sampled_pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

        <span class="c1"># Draw orbital periods for all companions as indices to the</span>
        <span class="c1"># tables in m1group.</span>
        <span class="n">logp_i_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">)])</span>

        <span class="n">lowmcomp_i_list</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># mass index of &lt; m1_min companions</span>
        <span class="n">highmcomp_i_list</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># mass index of &gt;= m1_min companions</span>

        <span class="c1"># Defaults to a success for isolated stars, i.e., ncomp=0.</span>
        <span class="n">success</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Start sampling from the innermost pair</span>
        <span class="k">for</span> <span class="n">order</span><span class="p">,</span> <span class="n">logp_i</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="n">logp_i_list</span><span class="p">))[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="c1"># open the drawn Table by its index</span>
            <span class="n">logp_table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m1group</span><span class="p">[</span><span class="n">logp_i</span><span class="p">]</span>
            <span class="c1"># get the corresponding logp</span>
            <span class="n">logp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">(</span><span class="n">logp_table</span><span class="o">.</span><span class="n">_v_title</span><span class="p">)</span>

            <span class="n">success</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">try_number</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">try_number</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">qe_max_tries</span><span class="p">:</span>
                <span class="c1"># Draw a q,e pair by its Table index.</span>
                <span class="n">qe_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">q_table</span> <span class="o">=</span> <span class="n">logp_table</span><span class="p">[</span><span class="n">qe_i</span><span class="p">][</span><span class="s1">&#39;q&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">e_table</span> <span class="o">=</span> <span class="n">logp_table</span><span class="p">[</span><span class="n">qe_i</span><span class="p">][</span><span class="s1">&#39;e&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">mcomp_table</span> <span class="o">=</span> <span class="n">q_table</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">m1_table</span>

                <span class="c1"># Check from which imf_array subarray mcomp_array</span>
                <span class="c1"># should be taken.</span>
                <span class="n">low_mcomp</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">if</span> <span class="n">mcomp_table</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">m1_min</span><span class="p">:</span>
                    <span class="n">low_mcomp</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="c1"># Look for the mass closest to mcomp_array in the</span>
                <span class="c1"># relevant imf_array.</span>
                <span class="c1"># Checks in place to avoid mass repetition.</span>
                <span class="k">if</span> <span class="n">low_mcomp</span><span class="p">:</span>
                    <span class="c1"># Check for mcomp such that mcomp &lt;= m1_min.</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lowmass_imf_array</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">lowmcomp_i_list</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># Force an option that will fail the tolerance</span>
                        <span class="c1"># test.</span>
                        <span class="n">mcomp_array</span> <span class="o">=</span> <span class="mf">0.9</span> <span class="o">*</span> <span class="n">mcomp_table</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dmcomp_tol</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Find closest mcomp in the array.</span>
                        <span class="n">mcomp_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lowmass_imf_array</span><span class="p">,</span> <span class="n">mcomp_table</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
                        <span class="c1"># Avoid out-of-bounds index due to searchsorted</span>
                        <span class="c1"># logic.</span>
                        <span class="k">if</span> <span class="n">mcomp_i</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">lowmass_imf_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                            <span class="n">mcomp_i</span> <span class="o">-=</span> <span class="mi">1</span>
                        <span class="c1"># If repeated, get index of next closest option.</span>
                        <span class="k">if</span> <span class="n">mcomp_i</span> <span class="ow">in</span> <span class="n">lowmcomp_i_list</span><span class="p">:</span>
                            <span class="n">mcomp_i</span> <span class="o">-=</span> <span class="mi">1</span>
                        <span class="n">mcomp_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lowmass_imf_array</span><span class="p">[</span><span class="n">mcomp_i</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Check for mcomp such that mcomp &lt;= m1.</span>
                    <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">highmass_imf_array</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">m1array_i</span><span class="p">])</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">highmcomp_i_list</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="c1"># Force an option that will fail the tolerance</span>
                        <span class="c1"># test.</span>
                        <span class="n">mcomp_array</span> <span class="o">=</span> <span class="mf">0.9</span> <span class="o">*</span> <span class="n">mcomp_table</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dmcomp_tol</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Because m1_array is slightly different from</span>
                        <span class="c1"># m1_table, sometimes a q equal to or close to 1</span>
                        <span class="c1"># will result in mcomp_table &lt;= m1_table but not</span>
                        <span class="c1"># m1_array, violating the definition of q. To</span>
                        <span class="c1"># avoid this, the search for mcomp_array is</span>
                        <span class="c1"># restricted beforehand to masses below</span>
                        <span class="c1"># m1_array.</span>
                        <span class="n">mcomp_i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">highmass_imf_array</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">m1array_i</span><span class="p">],</span>
                                                  <span class="n">mcomp_table</span><span class="p">,</span>
                                                  <span class="n">side</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">)</span>
                        <span class="c1"># Avoid out-of-bounds index due to searchsorted</span>
                        <span class="c1"># logic.</span>
                        <span class="k">if</span> <span class="n">mcomp_i</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">highmass_imf_array</span><span class="p">[:</span><span class="bp">self</span><span class="o">.</span><span class="n">m1array_i</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                            <span class="n">mcomp_i</span> <span class="o">-=</span> <span class="mi">1</span>
                        <span class="c1"># If repeated, get index of next closest option.</span>
                        <span class="k">while</span> <span class="n">mcomp_i</span> <span class="ow">in</span> <span class="n">highmcomp_i_list</span><span class="p">:</span>
                            <span class="n">mcomp_i</span> <span class="o">-=</span> <span class="mi">1</span>
                        <span class="n">mcomp_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">highmass_imf_array</span><span class="p">[</span><span class="n">mcomp_i</span><span class="p">]</span>

                <span class="c1"># Check whether the mass drawn from pairs_table and the</span>
                <span class="c1"># closest mass in imf_array are sufficiently close to be</span>
                <span class="c1"># accepted.</span>
                <span class="n">dmcomp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mcomp_table</span> <span class="o">-</span> <span class="n">mcomp_array</span><span class="p">)</span> <span class="o">/</span> <span class="n">mcomp_array</span>
                <span class="k">if</span> <span class="n">dmcomp</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dmcomp_tol</span><span class="p">:</span>
                    <span class="n">success</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">system_mass</span> <span class="o">+=</span> <span class="n">mcomp_table</span>  <span class="c1"># update system mass</span>
                    <span class="c1"># Keep track of already drawn masses to avoid</span>
                    <span class="c1"># repetition.</span>
                    <span class="k">if</span> <span class="n">low_mcomp</span><span class="p">:</span>
                        <span class="n">lowmcomp_i_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mcomp_i</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">highmcomp_i_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mcomp_i</span><span class="p">)</span>
                    <span class="c1"># Save relevant parameters for the innermost pair.</span>
                    <span class="c1"># The parameters of inner_pair and sampled_pair</span>
                    <span class="c1"># are NOT CUSTOMIZABLE (for now). Editing their</span>
                    <span class="c1"># definitions requires appropriately updating the</span>
                    <span class="c1"># column definitions in</span>
                    <span class="c1"># sampling.SimpleBinaryPopulation and is not</span>
                    <span class="c1"># recommended.</span>
                    <span class="k">if</span> <span class="n">order</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">inner_pair</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">m1_table</span><span class="p">,</span>  <span class="c1"># closest to m1_array</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">m1_array</span><span class="p">,</span>  <span class="c1"># from imf_array</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">dm1</span><span class="p">,</span>  <span class="c1"># relative difference between m1</span>
                            <span class="n">mcomp_table</span><span class="p">,</span>  <span class="c1"># mcomp drawn from pairs_table</span>
                            <span class="n">mcomp_array</span><span class="p">,</span>  <span class="c1"># closest to mcomp_table</span>
                            <span class="n">dmcomp</span><span class="p">,</span>  <span class="c1"># relative difference between mcomp</span>
                            <span class="n">q_table</span><span class="p">,</span>  <span class="c1"># mass ratio between table ms</span>
                            <span class="n">mcomp_array</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">m1_array</span><span class="p">,</span>
                            <span class="n">logp</span><span class="p">,</span>  <span class="c1"># log10(orbital period)</span>
                            <span class="n">e_table</span><span class="p">,</span>  <span class="c1"># eccentricity from table</span>
                            <span class="n">ncomp</span><span class="p">,</span>  <span class="c1"># number of companions</span>
                            <span class="n">system_mass</span>  <span class="c1"># primary + all companions</span>
                        <span class="p">])</span>
                        <span class="n">sampled_pairs</span> <span class="o">=</span> <span class="n">inner_pair</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">pair</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">mcomp_table</span><span class="p">,</span>
                                         <span class="n">mcomp_array</span><span class="p">,</span>
                                         <span class="n">logp</span><span class="p">,</span>
                                         <span class="n">e_table</span><span class="p">])</span>
                        <span class="n">outer_pairs</span><span class="p">[</span><span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="n">order</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span><span class="mi">4</span><span class="o">*</span><span class="n">order</span><span class="p">]</span> <span class="o">=</span> <span class="n">pair</span>
                    <span class="c1"># Automatically concludes the loop if successful.</span>
                    <span class="n">try_number</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qe_max_tries</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">try_number</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">success</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="c1"># If ncomp=0 (isolated star), this loop is skipped and</span>
        <span class="c1"># sampled_pairs remains an array of zeros. This is caught and</span>
        <span class="c1"># handled below by checking if system mass is zero.</span>

        <span class="c1"># Once a system has been built successfully,</span>
        <span class="c1"># All component masses are removed from imf_array and its</span>
        <span class="c1"># sub-arrays before returning the parameters.</span>
        <span class="k">if</span> <span class="n">success</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lowmass_imf_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lowmass_imf_array</span><span class="p">,</span> <span class="n">lowmcomp_i_list</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">highmass_imf_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">highmass_imf_array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m1array_i</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">highmass_imf_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">highmass_imf_array</span><span class="p">,</span> <span class="n">highmcomp_i_list</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="c1"># This was here to catch an old error that so far seems</span>
                <span class="c1"># to be fixed. Will be removed after further testing.</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s1">&#39;Out of bounds! highmass_imf_array shape is &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">highmass_imf_array</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s1"> and the array is &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">highmass_imf_array</span><span class="si">}</span><span class="s1">. Removed index &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">m1array_i</span><span class="si">}</span><span class="s1">, then attempted to remove indices &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">highmcomp_i_list</span><span class="si">}</span><span class="s1">.&#39;</span>
                <span class="p">)</span>
                <span class="c1"># Uncomment to catch warning if it occurs.</span>
                <span class="c1">#warnings.warn(</span>
                <span class="c1">#    &#39;Out of bounds! highmass_imf_array shape is &#39;</span>
                <span class="c1">#    f&#39;{self.highmass_imf_array.shape} and the array is &#39;</span>
                <span class="c1">#    f&#39;{self.highmass_imf_array}. Removed index &#39;</span>
                <span class="c1">#    f&#39;{self.m1array_i}, then attempted to remove indices &#39;</span>
                <span class="c1">#    f&#39;{highmcomp_i_list}.&#39;</span>
                <span class="c1">#)</span>
                <span class="n">sampled_pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">m1array_n</span> <span class="o">-=</span> <span class="mi">1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">highmcomp_i_list</span><span class="p">)</span>
                <span class="c1"># A success with a zero system mass in inner_pair</span>
                <span class="c1"># signals an isolated star with mass m1_table.</span>
                <span class="k">if</span> <span class="n">sampled_pairs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">sampled_pairs</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">m1_table</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m1_array</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dm1</span><span class="p">])</span>
                    <span class="n">sampled_pairs</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">system_mass</span>
                <span class="n">sampled_pairs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">sampled_pairs</span><span class="p">,</span> <span class="n">outer_pairs</span><span class="p">))</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">sampled_pairs</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Failed to build a valid system.&#39;</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Failed to build a valid system.&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span></div>
</div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Lucas de Sá.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>